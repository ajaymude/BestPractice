//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// ✅ Error Class Deep Dive (Notes)

// 1. The Built-in Error Class
// —————————————————————————————————————————————
// Every `new Error(message)` creates an Error instance with:
//   • message: human-readable description
//   • name: “Error” by default (or subclass name)
//   • stack: the stack trace (V8 engines)
//
// Example:
try {
  throw new Error('Oops');
} catch (err) {
  console.log(err.name);    // "Error"
  console.log(err.message); // "Oops"
  console.log(err.stack);   // stack trace
}

// 2. Built-In Error Subclasses
// —————————————————————————————————————————————
// JavaScript provides specialized errors:
//   • TypeError    – wrong data type
//   • ReferenceError – undefined variable
//   • RangeError   – value out of range
//   • SyntaxError  – invalid code syntax
//   • EvalError    – problems with eval()
//
// Example:
function square(n) {
  if (typeof n !== 'number') {
    throw new TypeError('square() expects a number');
  }
  return n * n;
}
// square('foo'); // throws TypeError: square() expects a number

// 3. Subclassing Error for Custom Errors
// —————————————————————————————————————————————
// Extend Error to carry extra info (e.g., HTTP status):
class HttpError extends Error {
  constructor(status, message) {
    super(message);
    this.name = this.constructor.name; // “HttpError”
    this.status = status;               // custom property
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
// Usage in Express:
app.get('/secret', (req, res, next) => {
  if (!req.user) {
    return next(new HttpError(401, 'Authentication required'));
  }
  res.send('Welcome!');
});

// 4. Checking Error Types
// —————————————————————————————————————————————
// Use `instanceof` to distinguish:
try {
  // …some code…
} catch (err) {
  if (err instanceof HttpError) {
    console.warn(`Status ${err.status}: ${err.message}`);
  } else {
    console.error('Unknown error:', err);
  }
}

// 5. Best Practices
// —————————————————————————————————————————————
// 1. Always throw Error objects (not strings).
// 2. Include clear, meaningful messages.
// 3. Centralize error handling via middleware (in Express).
// 4. Normalize all client responses to a consistent shape:
//    { status, name, message }.  
// 5. Log full stacks and context internally, but hide stacks from end users in production.
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////