





// ======================
// Redux Toolkit (RTK) Full Syllabus
// (Beginner to Expert)
// ======================

// üìò INTRODUCTION & SETUP
// 01 - What is Redux Toolkit and why use it?
// 02 - Comparison: Redux Toolkit vs Vanilla Redux vs Other State Libraries
// 03 - Installing Redux Toolkit: npm install @reduxjs/toolkit react-redux
// 04 - Project structure for RTK: organizing store, features, and slices
// 05 - Setting up the Redux store with configureStore()
// 06 - Integrating React-Redux: Provider component and useDispatch/useSelector hooks
// 07 - TypeScript support in RTK: defining RootState and AppDispatch types
// 08 - Enabling Redux DevTools with default configuration in RTK
// 09 - Using Redux Toolkit in a React Native environment (similar setup with react-native)

// üî§ CORE RTK CONCEPTS
// 10 - createSlice(): defining slice name, initial state, reducers, and auto-generated actions
// 11 - Slice reducers: ‚Äúmutating‚Äù syntax with Immer under the hood
// 12 - Action creators and action types generated by createSlice
// 13 - configureStore(): reducer object, middleware customization, devTools configuration
// 14 - combineReducers under the hood: slice reducers composed automatically
// 15 - createReducer utility: alternative to createSlice for custom logic
// 16 - createAction utility: manually defining action creators and matching with createReducer
// 17 - createImmutableStateInvariantMiddleware and serializableStateInvariantMiddleware explained

// üìà ASYNC LOGIC WITH createAsyncThunk
// 18 - Understanding async logic patterns: thunk middleware and async flow
// 19 - createAsyncThunk(): defining async thunks, action life-cycle (pending, fulfilled, rejected)
// 20 - Returning payload from createAsyncThunk: handling fulfilled and rejected actions
// 21 - ExtraReducers in createSlice: responding to pending/fulfilled/rejected action types
// 22 - ThunkAPI utils: dispatch, getState, signal, rejectWithValue for custom rejection
// 23 - Handling loading, success, and error states: patterns for slices using createAsyncThunk
// 24 - Cancelling async thunks: using signal.aborted and thunkAPI.signal
// 25 - Sequential vs parallel dispatch of async thunks

// üîÑ RTK QUERY FOR DATA FETCHING
// 26 - Introduction to RTK Query: automated data fetching and caching
// 27 - Installing RTK Query: part of @reduxjs/toolkit via createApi
// 28 - Defining API slice with createApi(): baseQuery, endpoints
// 29 - baseQuery with fetchBaseQuery: default settings, customizing headers and baseUrl
// 30 - Defining query endpoints: builder.query for GET requests
// 31 - Defining mutation endpoints: builder.mutation for POST/PUT/DELETE requests
// 32 - Auto-generated hooks: useGetXQuery, useMutation hooks in components
// 33 - Tag-based caching: providesTags and invalidatesTags for cache invalidation
// 34 - Manual cache invalidation: dispatching refetch or invalidating tags on certain actions
// 35 - Polling and refetchOnFocus/refetchOnReconnect options
// 36 - Selectors generated by RTK Query: selectXResult, providing manual control over caching
// 37 - Mutations and optimistic updates: providing placeholder data, undo functionality
// 38 - Prefetching data: dispatch(apiSlice.util.prefetch) and usePrefetch hook
// 39 - Handling loading and error states automatically via RTK Query hooks
// 40 - Streaming queries or subscriptions (if using websocket baseQuery or custom baseQuery)
// 41 - Integrating RTK Query with WebSocket or GraphQL: custom baseQuery implementations

// üìÅ FEATURE-BASED ORGANIZATION
// 42 - ‚ÄúDucks‚Äù pattern with createSlice: co-locating actions, reducers, and selectors
// 43 - Structuring features: folders per feature with slice.js, api.js (for RTK Query), and selectors.js
// 44 - Reusable slice patterns: common utility reducers, multi-entity patterns with createEntityAdapter
// 45 - Using createEntityAdapter: managing normalized state, CRUD operations, selectors
// 46 - Customizing entity adapter: selectId, sortComparer, additional reducers
// 47 - Combining multiple slices: importing and combining in rootReducer via configureStore
// 48 - Lazy-loading feature slices: dynamic reducer injection with Redux Toolkit

// üß© ADVANCED SLICE & REDUCER LOGIC
// 49 - createSelector (Reselect) usage within RTK: memoized selectors for derived data
// 50 - Cross-slice interactions: dispatching thunks from another slice, handling dependencies
// 51 - Using createAction to handle non-slice actions: global actions that multiple slices listen for
// 52 - Middleware customization: customizing the default middleware chain in configureStore
// 53 - Adding custom middleware: logger, crashReporter, analytics middleware in RTK store
// 54 - Writing slice-specific middleware: intercepting actions before reducers process them
// 55 - Immutable update patterns without Immer: manual immutable updates vs Immer‚Äôs auto-handling

// üß™ TESTING REDUX TOOLKIT LOGIC
// 56 - Testing slice reducers: passing initial state and actions to reducer functions
// 57 - Testing action creators: verifying correct action types and payloads from createSlice
// 58 - Testing async thunks created with createAsyncThunk: mocking fetch or axios, testing dispatch sequence
// 59 - Testing RTK Query endpoints: mocking network responses, using msw (Mock Service Worker)
// 60 - Testing selectors: using createSelector, providing sample state and comparing output
// 61 - End-to-end testing of store: configuring a test store with configureStore, dispatching actions, inspecting state
// 62 - Integration testing with React components: wrapping components with Provider and store, using React Testing Library to assert interactions

// ‚öô STORE CONFIGURATION & MIDDLEWARE
// 63 - Default middleware in RTK: serializableStateInvariantMiddleware, immutableStateInvariantMiddleware, thunk
// 64 - Disabling or customizing default middleware: passing getDefaultMiddleware options
// 65 - Adding custom middleware: writing a logging middleware that logs action and previous/next state
// 66 - Using redux-persist with RTK: persisting slices to localStorage or AsyncStorage
// 67 - Encrypting persisted state: using redux-persist-transform-encrypt for sensitive data
// 68 - Integrating saga or observable middleware: combining redux-saga or redux-observable with RTK store
// 69 - Using RTK‚Äôs built-in merge reducer logic with middleware: understanding middleware order

// üìà PERFORMANCE OPTIMIZATIONS
// 70 - Normalizing state with createEntityAdapter: avoiding nested arrays, improving update performance
// 71 - Memoized selectors with createSelector to prevent unnecessary recomputations
// 72 - Splitting large slices: breaking down into smaller slices to reduce re-render scope
// 73 - Batch dispatch of actions: grouping multiple updates in a single dispatch for performance
// 74 - Using Redux DevTools effectively: inspecting actions, time travel debugging, state diffing
// 75 - Limiting state shape complexity: storing only necessary data in Redux, moving ephemeral data to local component state
// 76 - Employing RTK Query‚Äôs caching to reduce network traffic and re-renders

// üì° INTEGRATING RTK WITH REACT
// 77 - Connecting React components to the store: useSelector and useDispatch hooks
// 78 - Typing useDispatch and useSelector in TypeScript: defining typed hooks (useAppDispatch, useAppSelector)
// 79 - Mapping state and dispatch to props in class components via connect (if still needed)
// 80 - Using React-Redux‚Äôs shallowEqual to avoid unnecessary re-renders in useSelector
// 81 - Patterns for splitting state between global (Redux) and local (component) state
// 82 - Encapsulating business logic in slices vs inside React components
// 83 - Handling derived UI state: storing UI-specific flags (modal open, pagination page) in Redux or local state
// 84 - Using RTK Query hooks directly in components for data fetching instead of manual dispatch

// üîß RTK QUERY ADVANCED FEATURES
// 85 - Customizing baseQuery: adding auth headers, handling refresh tokens, automatic re-login
// 86 - Manually invalidating cache: dispatch(apiSlice.util.invalidateTags) to force refetch
// 87 - Optimistic updates with onQueryStarted: dispatching update to cache, handling rollback on error
// 88 - Polling intervals and refetching strategies: refetchOnMountOrArgChange, refetchOnReconnect
// 89 - Subscription/unsubscription to cached data: using skipToken with hooks for conditional fetching
// 90 - Combining multiple endpoints: stitching responses from different endpoints, merging data arrays
// 91 - Customizing endpoint caching: setting keepUnusedDataFor and refetchOnFocus
// 92 - Lazy queries: using useLazyQuery hooks for manual trigger of requests
// 93 - Testing RTK Query caching and invalidation: mocking endpoints, verifying cache behavior

// üìä REAL-WORLD PATTERNS & BEST PRACTICES
// 94 - Feature flags in Redux: storing flag state, enabling/disabling features at runtime
// 95 - Handling pagination and infinite scroll: storing page/tokens in slice, merging new data
// 96 - Normalizing nested API responses: creatingEntityAdapter for multiple nested entities
// 97 - Managing optimistic UI flows: immediate updates in store, syncing with backend, rollback on failure
// 98 - Handling websockets in RTK: combining createAsyncThunk for initial load and websockets for live updates
// 99 - Decoupling UI from data-fetching logic: using selectors to shape data for components
// 100 - Cross-slice selectors: deriving state from multiple slices via createSelector

// üîí SECURITY & DATA SANITIZATION
// 101 - Sanitizing data before storing in Redux: validating payloads from createAsyncThunk
// 102 - Avoiding storing sensitive data in Redux: using RTK Query cache-only storage for tokens
// 103 - Encrypting persisted store data: integrating redux-persist-transform-encrypt
// 104 - Immutable state enforcement: understanding Immer‚Äôs limitations and best practices
// 105 - Preventing accidental mutation: disabling non-serializable checks only when necessary and understanding consequences

// üß™ TESTING RTK QUERY & STORE LOGIC
// 106 - Mocking fetchBaseQuery: creating a custom baseQuery for unit tests
// 107 - Using msw (Mock Service Worker) to intercept network calls in RTK Query tests
// 108 - Testing API slice endpoints: using selectEndpoints and mocking responses
// 109 - Testing optimistic updates in mutations: simulating errors and verifying rollback
// 110 - Integration testing component interactions: rendering components with Provider and verifying UI updates on data load

// üåê ADVANCED TYPE SCRIPTING WITH RTK & RTK QUERY
// 111 - Strongly typing slices: defining RootState, PayloadAction<T>, SliceState interfaces
// 112 - Typing createAsyncThunk: specifying return type, thunkArg type, and rejectValue type
// 113 - Typing RTK Query endpoints: defining BaseQueryApi, specifying types for query arguments and expected responses
// 114 - Inferred hook return types: extracting types from useGetXQuery hook results
// 115 - Creating typed hooks: useAppDispatch, useAppSelector to ensure correct types in components
// 116 - Using TypeScript generics with createEntityAdapter: typing entity IDs and entity shapes

// ‚öô MIGRATION & UPGRADE PATHS
// 117 - Migrating from vanilla Redux to Redux Toolkit: replacing createStore, combineReducers, applyMiddleware with configureStore
// 118 - Refactoring reducers and action creators to createSlice
// 119 - Replacing manual thunk logic with createAsyncThunk
// 120 - Incremental adoption: using RTK Query for data fetching alongside existing middleware
// 121 - Handling legacy non-serializable state: configuring middleware to ignore specific actions
// 122 - Best practices for code splitting: dynamic slice injection and feature-based store configuration

// üìà MONITORING & DEBUGGING
// 123 - Using Redux DevTools: time-travel debugging, action replay, state diffing
// 124 - Logging middleware: creating a custom middleware to log RTK actions and timings
// 125 - Tracking performance: measuring state update durations, using DevTools profiler
// 126 - Error boundary integration: catching errors in reducers or thunks and dispatching error actions
// 127 - Sentry integration: capturing Redux errors and actions as breadcrumbs

// üöÄ DEPLOYMENT & PRODUCTION OPTIMIZATIONS
// 128 - Configuring production store: disabling serializable and immutable checks in production
// 129 - Minimizing bundle size: using selective imports (import { createSlice } from '@reduxjs/toolkit'), avoiding unnecessary middleware
// 130 - Removing debug code: omitting Redux Logger in production builds
// 131 - Preloading state from server: hydrating Redux store with server-rendered state
// 132 - Server-Side Rendering (SSR) with RTK: configuring preloadedState in configureStore, using redux-persist with SSR
// 133 - Code splitting: loading feature slices only when needed (dynamic import of slice reducers)

// üèÜ CAREER & COMMUNITY
// 134 - Contributing to Redux Toolkit: following GitHub workflow, submitting pull requests
// 135 - Following Redux Toolkit release notes and RFCs: tracking changes and proposals on GitHub
// 136 - Learning resources: Redux Toolkit documentation, Redux Essentials tutorial, official examples
// 137 - Joining community channels: Redux Discord, Stack Overflow, GitHub Discussions
// 138 - Real-world use cases: studying open-source projects that leverage RTK and RTK Query
// 139 - Staying updated: subscribing to React Redux blog, following core maintainers on Twitter and GitHub

// ‚Äî END OF REDUX TOOLKIT SYLLABUS ‚Äî  









///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT MASTER SYLLABUS (WITH RTK QUERY - REM)

// üß† 1. CORE CONCEPTS
// - What is Redux?
// - Why use Redux Toolkit?
// - Problems with Traditional Redux
// - Benefits of Redux Toolkit

// ‚öôÔ∏è 2. SETUP
// - Installing Redux Toolkit and React-Redux
// - Setting up the Redux store
// - Integrating <Provider> with React

// üß± 3. SLICE
// - Creating a slice using createSlice
// - Defining name, initialState, reducers
// - Exporting actions and reducers

// üöÄ 4. DISPATCH & SELECT
// - useDispatch to trigger actions
// - useSelector to access state
// - Connecting components to the store

// üì¶ 5. REDUX DEVTOOLS
// - Enable and use Redux DevTools for debugging

// üîÅ 6. ASYNC LOGIC
// - createAsyncThunk for handling async operations
// - Handling pending, fulfilled, rejected states

// üß© 7. EXTRA REDUCERS
// - Defining extraReducers to manage asyncThunk
// - Separating logic for cleaner reducers

// üß™ 8. MIDDLEWARE
// - Redux Thunk middleware (default in RTK)
// - Adding custom middleware if needed

// üîó 9. MULTIPLE SLICES
// - Creating multiple slice files
// - Combining slices in configureStore
// - Managing modular feature-based state

// üßº 10. BEST PRACTICES
// - Feature-based folder structure
// - Clean and consistent naming
// - Keeping logic modular
// - Avoiding direct state mutations

// üß† 11. ADVANCED TOPICS
// - Using createEntityAdapter for normalized data
// - Memoization with reselect
// - Using TypeScript with Redux Toolkit
// - Writing unit tests for slices and async logic

// üåê 12. RTK QUERY (REM - REMOTE STATE MANAGEMENT)
// - Introduction to RTK Query
// - Setting up createApi service
// - Defining endpoints: query and mutation
// - Auto-generated React hooks
// - Caching, refetching, polling
// - Handling loading, error, data states
// - Optimistic updates and cache invalidation
// - Adding API reducer and middleware to the store

// üìÅ 13. FILE & FOLDER STRUCTURE
// - Organizing slices, services, and store setup
// - Suggested feature-based folder layout

// üí° 14. PRACTICAL PROJECT IDEAS
// - Blog App (posts, comments, user auth)
// - E-commerce Cart (products, checkout, orders)
// - Task Manager (todos, filters, CRUD with RTK Query)

// üèÅ You are now ready to start learning Redux Toolkit and RTK Query step by step!



//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// üß† 1. CORE CONCEPTS

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 1: CORE CONCEPTS

// üß† What is Redux?
// - Redux is a JavaScript library for managing application state globally.
// - It provides a central "store" where all the app's state lives.
// - Helps keep state predictable and manageable.
// - Commonly used with React but can work with any JavaScript framework.

// Example Use Case:
// - A shopping cart app: Redux stores cart data so all components (Product, Cart, Checkout) access the same source of truth.

// üí≠ Why Use Redux Toolkit?
// - Redux Toolkit (RTK) is the official, recommended way to use Redux.
// - It simplifies Redux setup and usage.
// - Reduces boilerplate code by combining actions and reducers in one place.
// - Built-in features: createSlice, configureStore, createAsyncThunk, createApi.

// ‚ö†Ô∏è Problems with Traditional Redux
// - Too much boilerplate: You write action types, action creators, and reducers separately.
// - Complex async logic: Required extra libraries like redux-thunk or redux-saga.
// - Scattered logic: State logic is split across multiple files per feature.
// - Manual setup: Had to manually integrate middleware and DevTools.

// ‚úÖ Benefits of Redux Toolkit
// - üß± createSlice: Combines reducer + actions in one function.
// - ‚öôÔ∏è configureStore: Simplifies store setup and includes DevTools + middleware.
// - üîÅ createAsyncThunk: Handles async operations with ease.
// - üåê createApi: Advanced API layer with auto caching, refetching (RTK Query).
// - üîí Built-in Immer: Allows "mutating" state safely using immutable logic.
// - üì¶ Cleaner, smaller codebase with less repetition.

// üèÅ Summary:
// Redux = centralized state management
// Redux Toolkit = modern, simplified, powerful way to use Redux

// ‚úÖ Next Step: Installation & Store Setup


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚öôÔ∏è 2. SETUP
// - Installing Redux Toolkit and React-Redux
// - Setting up the Redux store
// - Integrating <Provider> with React


// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 2: SETUP

// ‚öôÔ∏è INSTALLATION
// - Install Redux Toolkit and React-Redux using npm:
//   npm install @reduxjs/toolkit react-redux

// ‚öôÔ∏è SETTING UP THE STORE
// - Redux Toolkit provides `configureStore()` to create the store easily.
// - It automatically enables Redux DevTools and adds middleware like redux-thunk.

import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './features/counter/counterSlice'; // sample slice

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});

// ‚öõÔ∏è INTEGRATING <Provider> WITH REACT
// - Wrap your <App /> with <Provider store={store}> to make the store available in your app.

import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import App from './App';
import { store } from './app/store';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);

// ‚úÖ Summary:
// - Install @reduxjs/toolkit and react-redux
// - Use configureStore to create the store and add reducers
// - Use <Provider> in your main file to give access to Redux in your app

// ‚úÖ Next Step: Creating slices using createSlice


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// üß± 3. SLICE
// - Creating a slice using createSlice
// - Defining name, initialState, reducers
// - Exporting actions and reducers

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 3: SLICE

// üß± WHAT IS A SLICE?
// - A "slice" in Redux Toolkit represents a piece of the global state and its logic.
// - It includes:
//   - A name (used in actions and devtools)
//   - An initial state
//   - Reducers (functions that modify the state)
//   - Automatically generated actions
// - Redux Toolkit provides the `createSlice()` method to create all of this easily.

import { createSlice } from '@reduxjs/toolkit';

// ‚úÖ Example: Counter Slice
const counterSlice = createSlice({
  name: 'counter', // name of this slice
  initialState: { value: 0 }, // state structure
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    },
  },
});

// ‚úÖ Export actions to use in components
export const { increment, decrement, incrementByAmount } = counterSlice.actions;

// ‚úÖ Export reducer to use in the store
export default counterSlice.reducer;

// ‚úÖ Summary:
// - A slice defines a state + reducers + actions in one file
// - You use `createSlice()` to generate these easily
// - Export the actions to trigger them
// - Export the reducer to include it in configureStore

// ‚úÖ Next Step: Async logic with createAsyncThunk and extraReducers


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 4: DISPATCH & SELECT

// üöÄ PURPOSE:
// - To read data from the Redux store ‚Üí useSelector()
// - To send actions to the Redux store ‚Üí useDispatch()
// - These are React-Redux hooks and must be used inside function components

// ‚úÖ useSelector
// - Reads a specific value from the Redux state
// - You pass a function that returns the desired slice of state

// ‚úÖ useDispatch
// - Returns the dispatch function from the Redux store
// - You use it to trigger actions like increment, addTodo, etc.

import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount } from './counterSlice';

const Counter = () => {
  // Read data from Redux state
  const count = useSelector((state) => state.counter.value);

  // Get dispatch function to send actions
  const dispatch = useDispatch();

  return (
    <div>
      <h2>Count: {count}</h2>
      <button onClick={() => dispatch(increment())}>Increment +1</button>
      <button onClick={() => dispatch(decrement())}>Decrement -1</button>
      <button onClick={() => dispatch(incrementByAmount(5))}>Increment +5</button>
    </div>
  );
};

export default Counter;

// ‚úÖ Summary:
// - useSelector reads state from Redux store
// - useDispatch sends actions to update the store
// - These hooks connect React components to Redux

// ‚úÖ Next Step: Async logic with createAsyncThunk and extraReducers


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 5: REDUX DEVTOOLS

// üì¶ WHAT IS REDUX DEVTOOLS?
// - A powerful Chrome/Firefox extension for tracking Redux state changes
// - Allows you to inspect every dispatched action and see how state updates
// - Helps with debugging, testing, and understanding data flow in your app

// ‚úÖ FEATURES:
// - Time-travel debugging (go back in time through actions)
// - Inspect state before/after every action
// - Replay or cancel actions
// - Monitor performance

// ‚öôÔ∏è SETUP WITH REDUX TOOLKIT:
// - Redux Toolkit's `configureStore()` has DevTools enabled by default
// - You don‚Äôt need to manually install or configure anything extra

import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './features/counter/counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
  devTools: true, // this is true by default, added here just to show explicitly
});

export default store;

// üß™ How to use DevTools:
// - Install "Redux DevTools" extension in Chrome or Firefox
// - Open your app ‚Üí Inspect ‚Üí Redux tab (after interacting with your app)
// - You‚Äôll see a list of dispatched actions and state snapshots

// ‚úÖ Summary:
// - Redux DevTools help visualize state changes and debug easily
// - Enabled by default in Redux Toolkit
// - No extra setup required beyond using `configureStore`

// ‚úÖ Next Step: Handling async logic using createAsyncThunk


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 6: ASYNC LOGIC

// üîÅ WHY ASYNC LOGIC?
// - In real-world apps, you often need to fetch data from an API.
// - Redux Toolkit provides `createAsyncThunk()` to simplify handling async operations.
// - It automatically handles the three states of an async request:
//     1. pending
//     2. fulfilled
//     3. rejected

// ‚úÖ createAsyncThunk
// - Helps you define an async action (e.g., fetchUsers)
// - It auto-generates action types for the 3 states
// - Works seamlessly with `extraReducers` inside a slice

// ‚úÖ EXAMPLE: Fetch users from an API using createAsyncThunk

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

// Async thunk for fetching users
export const fetchUsers = createAsyncThunk('users/fetchUsers', async () => {
  const response = await axios.get('https://jsonplaceholder.typicode.com/users');
  return response.data;
});

// Slice to handle user state and async lifecycle
const userSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    loading: false,
    error: null,
  },
  reducers: {}, // no regular reducers here
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export default userSlice.reducer;

// ‚úÖ Summary:
// - Use createAsyncThunk to define API calls or other async work
// - Handle the result in extraReducers using builder.addCase()
// - Track loading, success, and error states in your state
// - Clean and powerful way to handle async in Redux Toolkit

// ‚úÖ Next Step: Handle side-effects using RTK Query (createApi)


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////


// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 7: EXTRA REDUCERS

// üß© WHAT ARE extraReducers?
// - extraReducers is a field inside createSlice that lets you respond to actions not defined in the slice‚Äôs own reducers.
// - Mainly used with createAsyncThunk to handle async actions (pending, fulfilled, rejected).
// - Keeps your slice clean by separating async logic from sync reducers.

// ‚úÖ WHY USE extraReducers?
// - When you use createAsyncThunk, it auto-generates action types (e.g., users/fetchUsers/pending).
// - You use extraReducers to handle those actions.
// - It's also used when a slice needs to respond to actions from other slices or APIs.

// ‚úÖ SYNTAX OPTIONS:
// - builder.addCase(action, reducerFunction)
// - builder.addMatcher(...)
// - builder.addDefaultCase(...)

import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

// Define an async thunk
export const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {
  const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
  return response.data;
});

// Create slice using extraReducers
const postsSlice = createSlice({
  name: 'posts',
  initialState: {
    posts: [],
    loading: false,
    error: null,
  },
  reducers: {
    // sync reducers (optional)
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchPosts.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.loading = false;
        state.posts = action.payload;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export default postsSlice.reducer;

// ‚úÖ Summary:
// - Use extraReducers when your slice depends on external actions like async thunk
// - Keeps reducers clean by separating sync and async logic
// - builder syntax gives you flexibility to match many action types

// ‚úÖ Next Step: RTK Query ‚Äì createApi and automated data fetching


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 8: MIDDLEWARE

// üß™ WHAT IS MIDDLEWARE?
// - Middleware in Redux is a function that intercepts every action before it reaches the reducer.
// - Used for side-effects like logging, async calls, API handling, analytics, etc.
// - Redux Toolkit includes Redux Thunk by default, so you can write async logic using functions.

// ‚úÖ THUNK MIDDLEWARE
// - Redux Thunk allows you to write action creators that return functions (not plain objects).
// - RTK includes it automatically in configureStore, so no need to add it manually.

// ‚úÖ ADDING CUSTOM MIDDLEWARE
// - You can pass a custom list of middleware in the `middleware` field of configureStore.
// - Useful for logging actions, performance tracking, auth, etc.

const customLoggerMiddleware = (storeAPI) => (next) => (action) => {
  console.log('Dispatching:', action);
  const result = next(action);
  console.log('Next State:', storeAPI.getState());
  return result;
};

import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './features/counter/counterSlice';

const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(customLoggerMiddleware),
});

export default store;

// ‚úÖ Summary:
// - Middleware allows you to extend Redux‚Äôs dispatch behavior.
// - Redux Thunk is included by default for async logic.
// - You can easily add custom middleware for logging, auth, analytics, etc.

// ‚úÖ Next Step: RTK Query ‚Äì createApi for remote data management




//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 9: MULTIPLE SLICES

// üîó WHY MULTIPLE SLICES?
// - Each feature in your app (auth, cart, users, products, etc.) should have its own slice.
// - This makes your code modular, maintainable, and easier to debug.
// - You can combine all slices in one root store using `configureStore`.

// ‚úÖ FILE STRUCTURE (recommended)
/*
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ store.js
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authSlice.js
‚îÇ   ‚îú‚îÄ‚îÄ cart/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cartSlice.js
‚îÇ   ‚îî‚îÄ‚îÄ counter/
‚îÇ       ‚îî‚îÄ‚îÄ counterSlice.js
*/

// ‚úÖ EXAMPLE: COMBINING MULTIPLE SLICES

import { configureStore } from '@reduxjs/toolkit';
import authReducer from '../features/auth/authSlice';
import cartReducer from '../features/cart/cartSlice';
import counterReducer from '../features/counter/counterSlice';

const store = configureStore({
  reducer: {
    auth: authReducer,
    cart: cartReducer,
    counter: counterReducer,
  },
});

export default store;

// ‚úÖ HOW TO ACCESS STATE IN COMPONENTS
// - useSelector((state) => state.auth)
// - useSelector((state) => state.cart)
// - useSelector((state) => state.counter.value)

// ‚úÖ Summary:
// - Create separate slice files for each feature
// - Import all reducers into your store and register them under the `reducer` field
// - This makes your Redux logic modular and scalable

// ‚úÖ Next Step: RTK Query ‚Äì Full API data management using createApi


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 10: BEST PRACTICES

// üßº WHY BEST PRACTICES MATTER?
// - Keeping your Redux Toolkit setup clean and consistent makes your project easier to read, debug, and scale.
// - Especially important for team collaboration and large applications.

// üóÇÔ∏è FEATURE-BASED FOLDER STRUCTURE
// - Organize your code by features, not by type (no global reducers/ folder).
// - Keeps all logic (slice, API, components) for one feature together.

/*
src/
‚îú‚îÄ‚îÄ app/              // store.js lives here
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authSlice.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoginForm.jsx
‚îÇ   ‚îú‚îÄ‚îÄ cart/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cartSlice.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CartView.jsx
‚îÇ   ‚îî‚îÄ‚îÄ user/
‚îÇ       ‚îú‚îÄ‚îÄ userSlice.js
‚îÇ       ‚îî‚îÄ‚îÄ userAPI.js
*/

// ‚úçÔ∏è CLEAN AND CONSISTENT NAMING
// - Name slices with feature names: `authSlice`, `cartSlice`
// - Name actions meaningfully: `loginUser`, `addToCart`, `fetchUserData`
// - Name state keys after feature: `state.auth`, `state.cart`

// üß± KEEPING LOGIC MODULAR
// - Keep each slice small and focused on one thing (e.g., cartSlice handles only cart logic).
// - Avoid putting unrelated logic in the same slice.
// - If logic grows too much, split it into multiple slices or service files.

// üîí AVOID DIRECT STATE MUTATIONS
// - Redux Toolkit uses Immer under the hood so you *can* write "mutating" code (e.g., state.value += 1)
// - But still keep reducer logic pure and predictable.
// - Don‚Äôt perform side-effects like API calls or setTimeout inside reducers.

// ‚úÖ Summary:
// - Organize by features for modularity
// - Name things clearly and consistently
// - Keep slice logic focused and small
// - Write safe, clear reducer logic even with Immer

// ‚úÖ Next Step: Advanced features like createEntityAdapter, RTK Query, and Optimistic Updates


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 11: ADVANCED TOPICS

// üß† WHY ADVANCED TOPICS?
// - These tools and techniques improve performance, scalability, maintainability, and developer productivity.
// - Essential for large projects and production-level applications.

// üîÅ USING createEntityAdapter
// - Used for managing normalized collections of data (like lists of users, posts, todos).
// - Automatically generates selectors (e.g., selectAll, selectById).
// - Improves performance when updating/deleting items in large lists.
// - Keeps state structured like:
//     {
//       ids: ['1', '2'],
//       entities: {
//         1: { id: '1', name: 'Alice' },
//         2: { id: '2', name: 'Bob' }
//       }
//     }

// üí° MEMOIZATION WITH RESELECT
// - `reselect` is a library used to create memoized selectors.
// - Prevents unnecessary re-renders in components by caching computed values.
// - Combine multiple pieces of state or compute derived values without performance loss.

// ‚úÖ USING TYPESCRIPT WITH REDUX TOOLKIT
// - RTK is built with TypeScript and provides full type safety out-of-the-box.
// - You can type:
//     - initial state
//     - action payloads
//     - thunk arguments and return types
//     - useSelector using RootState
// - Makes code safer and easier to refactor with strong IntelliSense and type checking.

// üß™ WRITING UNIT TESTS
// - You can write unit tests for slices, actions, and async logic.
// - Test pure reducers by passing fake actions and checking state changes.
// - Mock async functions to test thunks and async flow.
// - RTK slices are easy to test because of predictable structure and pure reducer logic.

// ‚úÖ Summary:
// - createEntityAdapter ‚Üí handle large normalized lists efficiently
// - reselect ‚Üí optimize performance with memoized selectors
// - TypeScript ‚Üí improves safety and developer experience
// - Testing ‚Üí ensures reliability and maintainability of Redux logic

// ‚úÖ Next Step: RTK Query ‚Äì Automated data fetching, caching, and mutations with createApi


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 12: RTK QUERY (REM ‚Äì Remote State Management)

// üåê INTRODUCTION TO RTK QUERY
// - RTK Query is a powerful data fetching and caching tool built into Redux Toolkit.
// - Eliminates the need for Axios, useEffect, and manual state handling for API calls.
// - Built on top of createApi() and fetchBaseQuery().

// üõ†Ô∏è SETTING UP createApi SERVICE
// - Use `createApi()` to define a centralized API service.
// - Inside it, define all API endpoints (GET, POST, PUT, DELETE, etc.).
// - RTK Query automatically generates React hooks for each endpoint.

// üßæ DEFINING ENDPOINTS: QUERY AND MUTATION
// - `builder.query()` is used for fetching data (GET).
// - `builder.mutation()` is used for creating, updating, deleting data (POST, PUT, DELETE).
// - You define each with:
//     - query: { url, method, body }
//     - optional: providesTags, invalidatesTags

// ‚öõÔ∏è AUTO-GENERATED REACT HOOKS
// - RTK Query creates custom hooks automatically based on endpoint names.
// - Examples:
//     - useGetPostsQuery()
//     - useAddUserMutation()
//     - useDeleteTodoMutation()

// üîÑ CACHING, REFETCHING, POLLING
// - Data is automatically cached and reused.
// - You can:
//     - Set `refetchOnMountOrArgChange: true`
//     - Enable background updates with pollingInterval
//     - Invalidate cache after mutation using `invalidatesTags`

// üîÅ HANDLING LOADING, ERROR, DATA STATES
// - Each query hook provides states:
//     - isLoading, isFetching, isError, error, data
// - You can show loaders, error messages, and UI based on these values

// ‚ö° OPTIMISTIC UPDATES AND CACHE INVALIDATION
// - Use `onQueryStarted` to apply changes to the UI before server response
// - Improves user experience for fast UI feedback
// - Use `invalidatesTags` and `providesTags` for automatic cache refresh after mutations

// üèóÔ∏è ADDING API REDUCER AND MIDDLEWARE TO STORE
// - In configureStore():
//     - Add the API‚Äôs reducer using `[api.reducerPath]: api.reducer`
//     - Add the middleware using `.concat(api.middleware)`

// ‚úÖ Summary:
// - RTK Query simplifies API handling with auto-generated hooks
// - Handles loading, error, and cache automatically
// - Reduces boilerplate for fetching, creating, updating, deleting data
// - Boosts performance and user experience with caching and optimistic updates

// ‚úÖ Next Step: Project structure, entity adapter, and real use cases



// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 12: RTK QUERY (REM ‚Äì Remote State Management)

// üåê INTRODUCTION TO RTK QUERY
// - RTK Query simplifies fetching, caching, and updating remote data.
// - It uses createApi to define endpoints and generates React hooks automatically.

// üõ†Ô∏è SETUP: createApi service

import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const userApi = createApi({
  reducerPath: 'userApi', // key in the Redux store
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com/' }),
  tagTypes: ['User'],
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => 'users',
      providesTags: ['User'],
    }),
    addUser: builder.mutation({
      query: (newUser) => ({
        url: 'users',
        method: 'POST',
        body: newUser,
      }),
      invalidatesTags: ['User'],
    }),
  }),
});

export const { useGetUsersQuery, useAddUserMutation } = userApi;

// üèóÔ∏è STORE SETUP: Add reducer and middleware

import { configureStore } from '@reduxjs/toolkit';
import { userApi } from './services/userApi';

const store = configureStore({
  reducer: {
    [userApi.reducerPath]: userApi.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(userApi.middleware),
});

export default store;

// ‚öõÔ∏è USAGE IN COMPONENT

import React, { useState } from 'react';
import { useGetUsersQuery, useAddUserMutation } from './services/userApi';

const UserList = () => {
  const { data: users, isLoading, isError } = useGetUsersQuery();
  const [addUser] = useAddUserMutation();
  const [newName, setNewName] = useState('');

  const handleAddUser = async () => {
    if (newName.trim()) {
      await addUser({ name: newName });
      setNewName('');
    }
  };

  if (isLoading) return <p>Loading...</p>;
  if (isError) return <p>Error loading users.</p>;

  return (
    <div>
      <h2>Users:</h2>
      <ul>
        {users?.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
      <input
        type="text"
        value={newName}
        onChange={(e) => setNewName(e.target.value)}
        placeholder="New user name"
      />
      <button onClick={handleAddUser}>Add User</button>
    </div>
  );
};

export default UserList;

// ‚úÖ Summary:
// - createApi defines endpoints with query and mutation
// - useGetUsersQuery and useAddUserMutation auto-generated
// - Built-in loading/error/data states make UI updates easier
// - Automatic caching, tag invalidation, and polling are supported



//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 13: FILE & FOLDER STRUCTURE

// üìÅ WHY FOLDER STRUCTURE MATTERS?
// - A clean, modular folder structure keeps your Redux code scalable and maintainable.
// - Separating concerns by feature (not by type) makes it easy to locate logic.
// - This approach is ideal for both small and large teams/projects.

// ‚úÖ FEATURE-BASED LAYOUT (RECOMMENDED)
/*
src/
‚îú‚îÄ‚îÄ app/                      // Global app configuration
‚îÇ   ‚îî‚îÄ‚îÄ store.js              // configureStore, setup for middleware and reducers
‚îÇ
‚îú‚îÄ‚îÄ features/                 // All Redux slices by feature
‚îÇ   ‚îú‚îÄ‚îÄ counter/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ counterSlice.js   // Logic for counter state
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authSlice.js      // Logic for login/register/logout
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ user/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ userSlice.js      // For local state like form inputs, modals
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ userAPI.js        // RTK Query service for user-related APIs
‚îÇ
‚îú‚îÄ‚îÄ services/                 // (optional) Shared RTK Query APIs if not tied to single feature
‚îÇ   ‚îî‚îÄ‚îÄ baseApi.js            // Shared createApi setup
‚îÇ
‚îú‚îÄ‚îÄ components/               // Reusable UI components
‚îÇ   ‚îî‚îÄ‚îÄ Header.jsx
‚îÇ
‚îú‚îÄ‚îÄ pages/                    // Page-level components (e.g., HomePage, LoginPage)
‚îÇ   ‚îî‚îÄ‚îÄ UserPage.jsx
‚îÇ
‚îú‚îÄ‚îÄ hooks/                    // Custom hooks (optional)
‚îÇ   ‚îî‚îÄ‚îÄ useDebounce.js
‚îÇ
‚îú‚îÄ‚îÄ App.jsx                   // Root React component
‚îî‚îÄ‚îÄ main.jsx / index.js       // React entry point with <Provider />
*/

// ‚úÖ FILE RESPONSIBILITIES

// - app/store.js:
//   - Combines all reducers and middleware
//   - Registers API services

// - features/[featureName]/[featureName]Slice.js:
//   - Holds state + actions for that feature using createSlice

// - features/[featureName]/[featureName]API.js:
//   - RTK Query createApi logic for backend communication

// - services/baseApi.js (optional):
//   - Shared API setup for reuse across features

// - components/:
//   - Reusable presentational components, not tied to Redux

// - pages/:
//   - Page-level layout that might use hooks from multiple slices/services

// ‚úÖ Summary:
// - Organize code by feature, not by type
// - Group slice and service files together
// - Keep store config separate and centralized in app/store.js

// ‚úÖ Next Step: Final practice task or project idea for applying everything


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// ‚úÖ REDUX TOOLKIT NOTES ‚Äì STEP 14: PRACTICAL PROJECT IDEAS

// üí° WHY BUILD PROJECTS?
// - Real-world projects help you apply everything you've learned.
// - You'll reinforce concepts like slices, asyncThunk, RTK Query, caching, and optimistic updates.

// üìù 1. BLOG APP (Posts, Comments, User Auth)
// üîπ Features:
//    - User login/register (authSlice)
//    - Fetch posts using RTK Query (getPosts query)
//    - Create, update, delete posts (mutations)
//    - Comment system (commentsSlice or RTK Query)
// üîπ Concepts Applied:
//    - createSlice, createAsyncThunk for auth
//    - createApi for posts & comments
//    - providesTags, invalidatesTags
//    - useSelector, useDispatch for local states (e.g., modals)

// üõí 2. E-COMMERCE CART APP (Products, Cart, Checkout)
// üîπ Features:
//    - Fetch product list from API (getProducts query)
//    - Add/remove items from cart (cartSlice)
//    - Order submission (orderSlice + RTK Query mutation)
// üîπ Concepts Applied:
//    - Modular slices (productSlice, cartSlice, orderSlice)
//    - RTK Query for backend integration
//    - Custom middleware for logging cart activity (optional)
//    - Optimistic UI updates when adding/removing items

// ‚úÖ 3. TASK MANAGER (CRUD with Filters)
// üîπ Features:
//    - Create, Read, Update, Delete tasks (tasks API)
//    - Filters: show all, completed, active tasks
//    - Toggle task completion
// üîπ Concepts Applied:
//    - createApi with builder.query & builder.mutation
//    - Entity Adapter for normalized task management
//    - Memoized selectors for filtering
//    - useSelector for task filters and counts

// ‚úÖ Summary:
// - Blog App ‚Üí Best for mastering CRUD with auth
// - E-Commerce ‚Üí Best for combining local + server state
// - Task Manager ‚Üí Best for normalized data, filters, and reselect

// ‚úÖ What‚Äôs Next?
// - Pick one project and build step-by-step using Redux Toolkit best practices
// - Start with store + slice structure, then connect components and APIs


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////











// 01 - installation npm install @reduxjs/toolkit react-redux
// 02 - create store
//    - configureStore
//               - reducer :{ cart:cartSliceReducer, auth:authReducer } // slice reducer
//               - middleware : (getDefaultMiddleware) => getDefaultMiddleware().concat(apiSlice.middleware) // add middleware
//               - devTools
// 03 - create slice
//    - createSlice
//               - name: 'counter' // name of the slice 
//               - initialState: { user:[], loading:false, error:null} // initial state
//               - reducers: { increment, decrement, incrementByAmount } // actions
//               - extraReducers: (builder) => { ... } // handle async actions
//                           - pending, fulfilled, rejected
//               - createAsyncThunk // create async actions
//               - export const { increment, decrement, incrementByAmount } = counterSlice.actions; // export actions
// 04 - connect react with the redux
//              - Provider
//              - store
// 05 - use redux in the react
//              - useSelector, useDispatch  
// 06 - rtk query
//             - createApi  
//             - injectEndpoints
//             - reducerPath
//             - baseQuery   
//                  - fetchBaseQuery
//                  - baseUrl
//             - endpoints
//             - builder.query
//                   - providesTags
//                   - query
//                        - url
//                        - method
//                        - body
//                   - invalidatesTags
//             - builder.mutation
//             - useGetUsersQuery
//             - useAddUserMutation 




/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

// 01 - installation 
// npm install @reduxjs/toolkit react-redux

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

// 02 - create store
//    - configureStore
//               - reducer :{ cart:cartSliceReducer, auth:authReducer } // slice reducer
//               - middleware : (getDefaultMiddleware) => getDefaultMiddleware().concat(apiSlice.middleware) // add middleware
//               - devTools




import { configureStore } from '@reduxjs/toolkit';
import { apiSlice } from './slices/apiSlice';
import cartSliceReducer from './slices/cartSlice';
import authReducer from './slices/authSlice';

const store = configureStore({
  reducer: {
    [apiSlice.reducerPath]: apiSlice.reducer,
    cart: cartSliceReducer,
    auth: authReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(apiSlice.middleware),
  devTools: true,
});

export default store;


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

// 03 - create slice
//    - createSlice
//               - name: 'counter' // name of the slice 
//               - initialState: { user:[], loading:false, error:null} // initial state
//               - reducers: { increment, decrement, incrementByAmount } // actions
//               - extraReducers: (builder) => { ... } // handle async actions
//                           - pending, fulfilled, rejected
//               - createAsyncThunk // create async actions
//               - export const { increment, decrement, incrementByAmount } = counterSlice.actions; // export actions








//    - Provider
//    - useSelector, useDispatch
//    - extraReducers
//    


//               - reducer :{ add:(state, action) => { state.value += action.payload; } }

// 03 - create  the slice 
import { createSlice } from '@reduxjs/toolkit';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => { state.value += 1; },
    decrement: (state) => { state.value -= 1; },
    incrementByAmount: (state, action) => { state.value += action.payload; }
  },
});

export const { increment, decrement, incrementByAmount } = counterSlice.actions;
// export default counterSlice.reducer;/


// slice with the asyncthunk 
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';

// Create an async thunk for fetching user data
export const fetchUsers = createAsyncThunk('users/fetchUsers', async () => {
  const response = await axios.get('https://jsonplaceholder.typicode.com/users');
  return response.data;
});

const userSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    loading: false,
    error: null,
  },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message;
      });
  },
});

export default userSlice.reducer;
// no need to export actions here, as we are only using async thunk


/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

// 04 - connect react with the redux
//              - Provider
//              - store


import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import store from './store';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')).render(
  <Provider store={store}>
    <App />
  </Provider>
);



/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

// 05 - use redux in the react
//              - useSelector, useDispatch  
// 



import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount } from './counterSlice';
import { useGetUsersQuery } from './services/userApi';


import {
  useGetPostsQuery,
  useAddPostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
} from './services/postApi';


const Counter = () => {

  // import and export the data from the redux store
  const count = useSelector((state) => state.counter.value);
  const dispatch = useDispatch();

  const { data: users, isLoading, error } = useGetUsersQuery();

  const { data: posts, isLoading } = useGetPostsQuery();
  const [addPost] = useAddPostMutation();
  const [updatePost] = useUpdatePostMutation();
  const [deletePost] = useDeletePostMutation();


    const handleAdd = async () => {
    if (newTitle.trim()) {
      await addPost({ title: newTitle, body: 'Demo body', userId: 1 });
      setNewTitle('');
    }
  };

  const handleUpdate = async (post) => {
    await updatePost({ ...post, title: post.title + ' (edited)' });
  };

  const handleDelete = async (id) => {
    await deletePost(id);
  };



  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error fetching users</p>;

  return (
  <div>
      <h1>Counter: {count}</h1>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
      <button onClick={() => dispatch(incrementByAmount(5))}>+5</button>


    <div>
      <h2>User List</h2>
      <ul>
        {users?.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  </div>



  );
};

export default Counter;



// use asyncthunk in the react 
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchUsers } from './userSlice';

const UserList = () => {
  const dispatch = useDispatch();
  const { users, loading, error } = useSelector((state) => state.users);

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error}</p>;

  return (
    <div>
      <h2>Users List</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
};

//   





/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

// 06 - rtk query
//             - createApi  
//             - injectEndpoints
//             - reducerPath
//             - baseQuery   
//                  - fetchBaseQuery
//                  - baseUrl
//             - endpoints
//             - builder.query
//                   - providesTags
//                   - query
//                        - url
//                        - method
//                        - body
//                   - invalidatesTags
//             - builder.mutation
//             - useGetUsersQuery
//             - useAddUserMutation 








// create slice 
// services/userApi.js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const userApi = createApi({
  reducerPath: 'userApi', // unique key in the store
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com/' }),
  endpoints: (builder) => ({
    getUsers: builder.query({
      query: () => 'users',
    }),
  }),
});

export const { useGetUsersQuery } = userApi;





import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const postApi = createApi({
  reducerPath: 'postApi',
  baseQuery: fetchBaseQuery({ baseUrl: 'https://jsonplaceholder.typicode.com/' }),
  tagTypes: ['Post'],
  endpoints: (builder) => ({
    // GET
    getPosts: builder.query({
      query: () => 'posts',
      providesTags: ['Post'],
    }),

    // CREATE
    addPost: builder.mutation({
      query: (newPost) => ({
        url: 'posts',
        method: 'POST',
        body: newPost,
      }),
      invalidatesTags: ['Post'],
    }),

    // UPDATE
    updatePost: builder.mutation({
      query: ({ id, ...updatedPost }) => ({
        url: `posts/${id}`,
        method: 'PUT',
        body: updatedPost,
      }),
      invalidatesTags: ['Post'],
    }),

    // DELETE
    deletePost: builder.mutation({
      query: (id) => ({
        url: `posts/${id}`,
        method: 'DELETE',
      }),
      invalidatesTags: ['Post'],
    }),
  }),
});

export const {
  useGetPostsQuery,
  useAddPostMutation,
  useUpdatePostMutation,
  useDeletePostMutation,
} = postApi;










/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////





/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
