


// ⚛️ REACT AND TYPESCRIPT (Optional Advanced)
// 85 - Adding TypeScript to React
// 86 - Typing props and state
// 87 - Typing event handlers
// 88 - Using generics

// 🧱 REACT NATIVE BASICS (Bonus)
// 89 - What is React Native?
// 90 - Setting up a basic app
// 91 - Core components and styling
// 92 - Navigation in RN


// 🧠 EXPERT-LEVEL CONCEPTS
// 93 - Refs and DOM access
// 94 - Forwarding refs
// 95 - Portals in React
// 96 - Error boundaries
// 97 - Render props and HOCs
// 98 - Compound components pattern
// 99 - Declarative animations (Framer Motion)
// 100 - Server components (React 19+ preview)

// 🧠 ADVANCED / BONUS TOPICS
// 101 - React 19 Actions and useFormStatus
// 102 - Streaming and partial rendering (React 19)
// 103 - React Compiler (signals and auto-memoization)
// 104 - Zustand and Jotai (lightweight state libs)
// 105 - React Query / TanStack Query
// 106 - E2E testing with Cypress / Playwright
// 107 - Skeleton loaders and shimmer effects
// 108 - Toast notifications (react-toastify)
// 109 - Accessibility (ARIA, tab order, focus trap)
// 110 - Dark/light theme toggling
// 111 - React + Docker containerization
// 112 - CI/CD with GitHub Actions / Vercel
// 113 - Performance audits with Lighthouse
// 114 - Bundle analysis (Webpack, Vite, source-map-explorer)
// 115 - Atomic design pattern
// 116 - Feature-based folder structure
// 117 - Secure token handling (HttpOnly, localStorage)
// 118 - Using .env securely in production
// 119 - Animating route transitions
// 120 - Advanced routing strategies in large apps




///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////



// Topic 85: Adding TypeScript to React – Detailed Notes and Code Examples
//
// Integrating TypeScript into a React project enhances type safety,
// improves developer productivity, and catches errors at compile time.
// Below are setup steps, key concepts, and sample code.
//
// 1. Initial Setup:
//    • Create React App with TS template:
//      npx create-react-app my-app --template typescript
//    • Or add TS to existing project:
//      npm install --save-dev typescript @types/react @types/react-dom
//      Rename .js/.jsx files to .ts/.tsx
//
// 2. tsconfig.json:
//    • Generated by CRA or configured manually.
//    • Key options:
//      - "jsx": "react-jsx"
//      - "strict": true for full type checking
//      - "moduleResolution": "node"
//
// 3. Typing Components:
//    • Function component with props interface:
//      interface ButtonProps { onClick: () => void; children: React.ReactNode; }
//      const Button: React.FC<ButtonProps> = ({ onClick, children }) => (
//        <button onClick={onClick}>{children}</button>
//      );
//
//    • Props default values via default parameters or utility types.
//
// 4. useState and useRef Hooks:
//    • useState with generic: const [count, setCount] = useState<number>(0);
//    • useRef with element type: const inputRef = useRef<HTMLInputElement>(null);
//
// 5. Event Typing:
//    • React.ChangeEvent<HTMLInputElement> for input change events.
//    • React.MouseEvent<HTMLButtonElement> for button clicks.
//
// 6. Context and Hooks:
//    • createContext<Type | undefined>(undefined);
//    • custom hooks return typed values: function useAuth(): AuthContextType { ... }
//
// 7. Typing API Calls:
//    • Define interfaces for response data.
//    • useFetch hook with generics: function useFetch<T>(url: string): { data?: T; ... }
//
// Code Example: Typed Button Component
import React, { useState, useRef, ChangeEvent, MouseEvent } from 'react';

interface ButtonProps {
  onClick: (e: MouseEvent<HTMLButtonElement>) => void;
  label: string;
}

export const Button: React.FC<ButtonProps> = ({ onClick, label }) => {
  return <button onClick={onClick}>{label}</button>;
};

// Code Example: Typed useState and useRef
export function TextInput() {
  const [value, setValue] = useState<string>('');
  const inputRef = useRef<HTMLInputElement>(null);

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  };

  return (
    <div>
      <input ref={inputRef} value={value} onChange={handleChange} />
      <p>Value: {value}</p>
    </div>
  );
}

// Code Example: Generic useFetch Hook
interface ApiResponse<T> {
  data: T;
  error: string | null;
  loading: boolean;
}

export function useFetch<T>(url: string): ApiResponse<T> {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  React.useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then((json: T) => {
        setData(json);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [url]);

  return { data: data as T, error, loading };
}

// Notes:
// • Leverage TypeScript’s strict mode for maximum safety.
// • Use interfaces and types to model props, state, and API contracts.
// • Utilize utility types (Partial, Pick, Omit) for flexible prop definitions.
// • Migrate incrementally: start typing critical components and hooks first.
// • Enable editor integrations for autocomplete and inline type checking.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// Topic 86: Typing Props and State in React with TypeScript – Detailed Notes and Code Examples
//
// Correctly typing props and component state enhances safety and clarity.
// Use interfaces or type aliases for props and generics for state hooks.
//
// 1. Defining Props Types:
//    • Use interface or type:
//      interface UserCardProps { id: number; name: string; active?: boolean; }
//    • Default props via optional or default values:
//      const UserCard: React.FC<UserCardProps> = ({ active = false, ... }) => {...};
//
// 2. Typing useState:
//    • Provide a generic parameter: const [count, setCount] = useState<number>(0);
//    • For complex objects, use type or interface:
//      interface FormData { email: string; password: string; }
//      const [form, setForm] = useState<FormData>({ email: '', password: '' });
//
// 3. Functional Component Example:
import React, { useState, ChangeEvent } from 'react';

interface UserCardProps {
  id: number;
  name: string;
  active?: boolean; // optional prop
}

export const UserCard: React.FC<UserCardProps> = ({ id, name, active = false }) => {
  return (
    <div className={`card ${active ? 'active' : ''}`}> 
      <h3>{name} (#{id})</h3>
      <p>Status: {active ? 'Active' : 'Inactive'}</p>
    </div>
  );
};

// 4. State in Form Component:
interface LoginFormState {
  email: string;
  password: string;
}

export function LoginForm() {
  const [form, setForm] = useState<LoginFormState>({ email: '', password: '' });

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value }));
  };

  return (
    <form>
      <input name="email" value={form.email} onChange={handleChange} placeholder="Email" />
      <input name="password" type="password" value={form.password} onChange={handleChange} placeholder="Password" />
      <button type="submit">Login</button>
    </form>
  );
}

// 5. Complex State with Union Types:
export function StatusToggle() {
  type Status = 'idle' | 'loading' | 'success' | 'error';
  const [status, setStatus] = useState<Status>('idle');

  const handleClick = () => setStatus('loading');

  return (
    <div>
      <button onClick={handleClick}>Load</button>
      <p>Current status: {status}</p>
    </div>
  );
}

// 6. Notes:
// • Always specify state types when initializing with null or empty arrays.
// • Use optional props or default values to handle missing props.
// • Leverage union types for state that can have discrete values.
// • Combine with utility types (Record, Partial) for more advanced typing.
// • Enforce strictNullChecks in tsconfig for safer null handling.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 87: Typing Event Handlers in React with TypeScript – Detailed Notes and Code Examples
//
// Accurately typing event handlers ensures correct event object access
// and prevents runtime errors. React provides specific types for various events.
//
// 1. Common Event Types:
//    • React.MouseEvent<T>          – mouse events (click, mouseEnter)
//    • React.ChangeEvent<T>         – input, textarea, select change events
//    • React.KeyboardEvent<T>       – keyboard events (keyDown, keyPress)
//    • React.FormEvent<T>           – form submission events
//    • React.FocusEvent<T>          – focus and blur events
//    • React.UIEvent<T>             – UI events like scroll
//    • React.SyntheticEvent<T>       – base type for all React events
//
// 2. Generic Parameter:
//    • T is the HTML element type (e.g., HTMLButtonElement, HTMLInputElement)
//    • Use accurate element type to access event.currentTarget properties.
//
// 3. Example: Button Click Handler
import React from 'react';

export function ClickButton() {
  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    console.log('Button clicked at', e.clientX, e.clientY);
  };

  return <button onClick={handleClick}>Click Me</button>;
}

// 4. Example: Input Change Handler
export function TextInput() {
  const [value, setValue] = React.useState<string>('');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  };

  return <input type="text" value={value} onChange={handleChange} placeholder="Type" />;
}

// 5. Example: Form Submit Handler
export function LoginForm() {
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    // access form values via refs or state
    console.log('Form submitted');
  };

  return (
    <form onSubmit={handleSubmit}>
      <button type="submit">Submit</button>
    </form>
  );
}

// 6. Example: Keyboard Event Handler
export function KeyPressInput() {
  const handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {
    if (e.key === 'Enter') {
      console.log('Enter pressed');
    }
  };

  return <div tabIndex={0} onKeyDown={handleKeyPress}>Focus and press Enter</div>;
}

// Notes:
// • Always specify the correct HTML element in generic parameter.
// • Use React.SyntheticEvent for generic handlers where element type varies.
// • Prevent default behaviors with e.preventDefault() in mouse and form events.
// • Autocomplete in editors improves with explicit types for event handlers.
// • For custom components, define props like onClick?: React.MouseEventHandler<T> for shorthand.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// ==============================
// 88 - Using Generics in React
// ==============================

// 📘 What are Generics?
// Generics allow you to write reusable, flexible functions or components
// that can work with a variety of types rather than a single type.

// 🔧 Generic Function Example:
function identity<T>(arg: T): T {
  return arg;
}

const output1 = identity<string>("Hello, Generics!");
const output2 = identity<number>(42);

// 🔧 Using Generics in React Component Props
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

// ✅ Generic React Component
function GenericList<T>({ items, renderItem }: ListProps<T>) {
  return <ul>{items.map((item, index) => <li key={index}>{renderItem(item)}</li>)}</ul>;
}

// 🔥 Usage Example of GenericList Component
const stringItems = ["React", "TypeScript", "Generics"];
const numberItems = [1, 2, 3, 4, 5];

function App() {
  return (
    <>
      <GenericList
        items={stringItems}
        renderItem={(item) => <span>{item}</span>}
      />
      <GenericList
        items={numberItems}
        renderItem={(item) => <strong>{item}</strong>}
      />
    </>
  );
}

// 📌 Benefits of Generics:
// - Reusability of components and functions
// - Enhanced type safety
// - Improved flexibility

// 📌 Common Use-Cases:
// - Generic lists and tables
// - Custom hooks with varying data types
// - Forms and input handlers

// 🛠️ Best Practices:
// - Clearly define your generic types
// - Avoid overly complex generics
// - Use constraints when needed (e.g., <T extends {...}>)

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// ==============================
// 89 - What is React Native?
// ==============================

// 📘 Introduction
// React Native is a popular JavaScript framework developed by Facebook for building native mobile applications using React. It enables developers to use JavaScript and React to create apps that behave and perform like native applications.

// 🔧 Key Features
// - Cross-platform: Build mobile apps for iOS and Android using a single codebase.
// - Native performance: Uses native components rather than web components.
// - React ecosystem: Leverages familiar React concepts like components, state, and props.

// 🔥 Basic Example of React Native Component
import React from 'react';
import { Text, View, StyleSheet } from 'react-native';

const App = () => (
  <View style={styles.container}>
    <Text style={styles.text}>Hello, React Native!</Text>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  text: {
    fontSize: 20,
    fontWeight: 'bold',
  },
});

export default App;

// 📌 Why Choose React Native?
// - Faster development cycles
// - Hot Reloading
// - Strong community support
// - Cost-effective compared to separate native apps

// 📌 Common Use-Cases:
// - Mobile apps with shared logic across platforms
// - Prototyping quickly and efficiently

// 🛠️ Important Tools & Libraries:
// - Expo: Simplifies React Native development
// - React Navigation: Navigation solution
// - Redux Toolkit / Zustand: State management libraries

// 📚 Summary
// React Native combines the best parts of native development with React, enabling efficient, scalable, and performant mobile app development.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// ==============================
// 90 - Setting up a Basic React Native App
// ==============================

// 📘 Steps to Set Up a React Native App

// 🔧 Step 1: Install Node.js and npm
// Ensure Node.js (LTS recommended) and npm are installed.

// 🔧 Step 2: Install Expo CLI
// Expo CLI simplifies React Native development.
npm install -g expo-cli

// 🔧 Step 3: Create a New React Native App
expo init MyReactNativeApp

// 🔧 Step 4: Navigate to Project Directory
cd MyReactNativeApp

// 🔧 Step 5: Start the Development Server
npm start

// 🔥 Basic React Native App Structure
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Welcome to React Native!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  text: {
    fontSize: 18,
    color: '#333',
  },
});

// 📌 Running the App
// - Scan the QR code in Expo Go App (Android/iOS)
// - Use emulator (Android Studio) or simulator (Xcode)

// 📌 Key Commands
// - npm start: Run development server
// - npm run android: Launch on Android emulator/device
// - npm run ios: Launch on iOS simulator/device

// 🛠️ Recommended Tools
// - Expo Go (mobile app for live preview)
// - VS Code (code editor)

// 📚 Summary
// Setting up a React Native app involves installing Expo CLI, creating a new project, and running it on a device or emulator, offering a streamlined development experience.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////



// ==============================
// 91 - Core Components & Styling in React Native
// ==============================

// 📘 Introduction
// React Native ships with a rich set of core components that map directly to native UI building blocks.
// These include View, Text, Image, ScrollView, TextInput, FlatList, SectionList, SafeAreaView, StatusBar, and touchables.
// Styling is accomplished via the StyleSheet API, which uses a CSS‑like layout system powered by Flexbox.

// 🔧 Common Core Components
// - View               : Container for layout & styling (like <div>)
// - Text               : Displays text strings
// - Image              : Renders images from URI or local asset
// - ScrollView         : Scrollable container for variable‑height content
// - TextInput          : User text entry field
// - TouchableOpacity   : Wrapper providing press / opacity feedback
// - Button             : Basic cross‑platform button
// - FlatList / SectionList : Highly‑performant scrolling list components
// - SafeAreaView       : Renders content within safe boundaries on iOS/Android
// - StatusBar          : Control the native status bar style

// 🔥 Example: Core Components with Styled UI
import React from 'react';
import {
  View,
  Text,
  Image,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
} from 'react-native';

export const CoreDemo = () => (
  <ScrollView contentContainerStyle={coreStyles.container}>
    <Text style={coreStyles.heading}>Core Components Demo</Text>

    {/* Image Component */}
    <Image
      style={coreStyles.image}
      source={{ uri: 'https://reactnative.dev/img/tiny_logo.png' }}
    />

    {/* TextInput Component */}
    <TextInput
      style={coreStyles.input}
      placeholder="Type here…"
    />

    {/* TouchableOpacity Component */}
    <TouchableOpacity style={coreStyles.button}>
      <Text style={coreStyles.buttonText}>Press Me</Text>
    </TouchableOpacity>
  </ScrollView>
);

const coreStyles = StyleSheet.create({
  container: {
    flexGrow: 1,
    paddingVertical: 40,
    alignItems: 'center',
    backgroundColor: '#F5FCFF',
  },
  heading: {
    fontSize: 24,
    fontWeight: '600',
    marginBottom: 20,
  },
  image: {
    width: 80,
    height: 80,
    marginBottom: 20,
  },
  input: {
    width: '80%',
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 8,
    padding: 10,
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#6200ee',
    paddingVertical: 12,
    paddingHorizontal: 30,
    borderRadius: 8,
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

// 📌 Styling Highlights
// - Flexbox is the default layout model (justifyContent, alignItems, flexDirection).
// - Units are *device‑independent pixels* (DIPs) – no px/%, just numbers.
// - Colors can be hex (#RRGGBB[AA]), rgb(), or named colors ("red").
// - Use StyleSheet.create() to freeze styles for performance.
// - Styles can be composed with arrays: <View style={[styles.base, styles.primary]}>.

// 🛠️ Best Practices
// - Keep style objects outside render to avoid re‑creates.
// - Prefer functional components with hooks.
// - Extract reusable UI into custom components.
// - Use FlatList for large data sets (virtualized rendering).
// - Test on multiple screen sizes & platforms.

// 📚 Summary
// Mastering core components and StyleSheet is essential for building performant, maintainable UIs in React Native.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// ==============================
// 92 - Navigation in React Native
// ==============================

// 📘 Why Navigation Matters
// Mobile apps consist of multiple screens; handling transitions, passing
// parameters, and managing history is critical for great UX.

// 🔧 Installing React Navigation & Peer Deps
// $ npm install @react-navigation/native
// $ npm install @react-navigation/stack
// $ npm install react-native-screens react-native-safe-area-context
// (Expo) $ expo install react-native-gesture-handler react-native-reanimated
// (Bare iOS) $ npx pod-install ios

// 🔥 Example: Simple Stack Navigator (TypeScript)
import * as React from 'react';
import { Button, View, Text } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

type RootStackParamList = {
  Home: undefined;
  Details: { id: number };
};

const Stack = createStackNavigator<RootStackParamList>();

function HomeScreen({ navigation }: { navigation: any }) {
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Home Screen</Text>
      <Button title="Go to Details" onPress={() => navigation.navigate('Details', { id: 42 })} />
    </View>
  );
}

function DetailsScreen({ route, navigation }: { route: any; navigation: any }) {
  const { id } = route.params;
  return (
    <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}>
      <Text>Details Screen — id: {id}</Text>
      <Button title="Go Back" onPress={() => navigation.goBack()} />
    </View>
  );
}

export default function NavigationDemo() {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Details" component={DetailsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// 📌 Passing Params & Config Options
// navigation.navigate('Details', { id: 42 })  // route.params.id in DetailsScreen
// <Stack.Screen name="Home" options={{ headerShown: false }} />

// 🔧 Other Navigator Types
// - createBottomTabNavigator   → bottom tab bar
// - createDrawerNavigator      → side drawer menu
// Navigators can be nested (e.g., Tabs inside a Stack).

// 🛠️ Best Practices
// - Wrap your root in <NavigationContainer> only once.
// - Enable react-native-screens for memory/perf gains.
// - Use TypeScript generics for param lists to ensure type‑safe navigation.
// - Extract complicated navigation setups into separate files.
// - Configure deep linking for universal links/URL schemes.

// 📚 Summary
// React Navigation provides a robust, flexible API (Stack, Tab, Drawer, etc.)
// for orchestrating smooth multi‑screen flows in React Native apps.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// ==============================
// 93 - Refs and DOM Access (React)
// ==============================

// 📘 Introduction
// Refs (short for *references*) let you access and interact with a DOM element
// or a class component instance directly, bypassing the usual React data flow.
// In modern React (function components) you typically use the `useRef` hook.
// In class components you create refs via `React.createRef()`.

// ⚙️ Creating a Ref with useRef
import React, { useRef, useEffect } from 'react';

export const AutoFocusInput = () => {
  // `inputRef` will persist for the component’s lifetime (does not re‑create)
  const inputRef = useRef<HTMLInputElement | null>(null);

  useEffect(() => {
    // When the component mounts, focus the input element
    inputRef.current?.focus();
  }, []);

  return <input ref={inputRef} placeholder="I get focused on mount" />;
};

// 🔧 Callback Refs (fine‑grained control)
// Useful when you need to run logic at attach/detach or manage multiple refs.
export const MeasureHeight = () => {
  const handleRef = (node: HTMLDivElement | null) => {
    if (node) {
      console.log('Height is', node.getBoundingClientRect().height);
    }
  };

  return (
    <div ref={handleRef} style={{ background: '#f2f2f2', padding: '1rem' }}>
      Measure my height on attach
    </div>
  );
};

// ➡️ Forwarding Refs to Child Components
// `forwardRef` passes a parent ref to a child’s DOM node.
import { forwardRef } from 'react';

type FancyInputProps = React.InputHTMLAttributes<HTMLInputElement> & {
  label: string;
};

export const FancyInput = forwardRef<HTMLInputElement, FancyInputProps>(
  ({ label, ...props }, ref) => (
    <label style={{ display: 'block' }}>
      {label}
      <input ref={ref} {...props} />
    </label>
  )
);

// Parent usage
export const Parent = () => {
  const ref = useRef<HTMLInputElement | null>(null);
  return (
    <>
      <FancyInput ref={ref} label="Name:" />
      <button onClick={() => ref.current?.focus()}>Focus Child Input</button>
    </>
  );
};

// 🚀 useImperativeHandle (expose controlled instance API)
import { useImperativeHandle } from 'react';

type CounterHandle = {
  reset: () => void;
};

export const ImperativeCounter = forwardRef<CounterHandle, {}>((_, ref) => {
  const countRef = useRef(0);
  useImperativeHandle(ref, () => ({
    reset() {
      countRef.current = 0;
      alert('Counter reset');
    },
  }));
  return (
    <button onClick={() => ++countRef.current}>Clicked {countRef.current} times</button>
  );
});

export const CounterParent = () => {
  const counterRef = useRef<CounterHandle>(null);
  return (
    <>
      <ImperativeCounter ref={counterRef} />
      <button onClick={() => counterRef.current?.reset()}>Reset Counter</button>
    </>
  );
};

// 🛠️ Best Practices
// - **Avoid overusing refs**: Prefer state & props when possible.
// - **Do not mutate DOM directly**: Use refs mainly for focus, measurements,
//   scroll position, or integrating non‑React libraries.
// - **Treat ref values as mutable containers**: Changing `ref.current` doesn’t
//   trigger re‑renders.
// - **Always initialise refs** (`useRef(null)`) to handle undefined gracefully.

// 📚 Summary
// Refs unlock direct DOM manipulation when needed. Master `useRef`,
// callback refs, `forwardRef`, and `useImperativeHandle` to integrate native
// APIs, animations, or third‑party libraries safely within React’s declarative
// world.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// ==============================
// 94 - Forwarding Refs in React
// ==============================

// 📘 What is Ref Forwarding?
// Ref forwarding is a pattern that lets a parent component access a child
// component's DOM node (or React element) directly by *forwarding* the ref
// through the child to one of its descendants.
// It is implemented with `React.forwardRef`—a higher‑order function that
// creates a component capable of receiving `ref` as the second argument.

// 🔧 Basic Syntax
// const FancyInput = React.forwardRef((props, ref) => { ... });
// The `ref` passed from the parent becomes available inside the child and can
// be attached to a DOM element or another component that supports refs.

// 🔥 Example 1: Simple ForwardRef TextInput (TypeScript)
import React, { forwardRef, useRef } from 'react';

interface FancyInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  label?: string;
}

export const FancyInput = forwardRef<HTMLInputElement, FancyInputProps>(
  ({ label = 'Label', ...rest }, ref) => (
    <label style={{ display: 'block', fontFamily: 'sans‑serif' }}>
      {label}
      <input ref={ref} {...rest} />
    </label>
  )
);

// Parent component using FancyInput
export const ForwardRefDemo = () => {
  const inputRef = useRef<HTMLInputElement | null>(null);

  const focusInput = () => {
    inputRef.current?.focus();
  };

  return (
    <div>
      <FancyInput ref={inputRef} placeholder="Click button to focus" />
      <button onClick={focusInput}>Focus Child Input</button>
    </div>
  );
};

// ➡️ Example 2: Forwarding to a Custom Button & Using ImperativeHandle
// Sometimes you expose custom imperative methods rather than raw DOM access.
import { useImperativeHandle } from 'react';

interface FancyButtonHandle {
  shake: () => void;
}

export const FancyButton = forwardRef<FancyButtonHandle, React.ButtonHTMLAttributes<HTMLButtonElement>>(
  (props, ref) => {
    const btnRef = useRef<HTMLButtonElement | null>(null);

    // Expose a custom 'shake' method to the parent
    useImperativeHandle(ref, () => ({
      shake() {
        const btn = btnRef.current;
        if (!btn) return;
        btn.animate([
          { transform: 'translateX(0px)' },
          { transform: 'translateX(-6px)' },
          { transform: 'translateX(6px)' },
          { transform: 'translateX(0px)' },
        ], { duration: 300, easing: 'ease‑in‑out' });
      },
    }));

    return <button ref={btnRef} {...props} />;
  }
);

export const ButtonParent = () => {
  const buttonRef = useRef<FancyButtonHandle>(null);
  return (
    <>
      <FancyButton ref={buttonRef}>Shake Me!</FancyButton>
      <button onClick={() => buttonRef.current?.shake()}>Trigger Shake</button>
    </>
  );
};

// 🛠️ Best Practices & Gotchas
// - **Only forward refs when necessary**: don’t expose internal nodes by
//   default—keep components encapsulated.
// - **Use generic types** for props & ref to maintain type safety in TS.
// - **Avoid ref forwarding through HOCs** unless wrapped with `React.forwardRef`.
// - **Do not mutate DOM directly** beyond what is needed (focus, measurement).
// - **Combine with `useImperativeHandle`** when exposing controlled methods.

// 📚 Summary
// Ref forwarding is essential for reusable, higher‑order components (forms,
// animations, libraries) that still need to grant parent‑level DOM access or
// imperative methods. Mastering it unlocks advanced React patterns while
// preserving a clear, declarative API surface.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////



// ==============================
// 95 - Portals in React
// ==============================

// 📘 What Are Portals?
// Portals allow you to render children into a DOM node that exists outside the
// DOM hierarchy of the parent component. This is accomplished with
// `ReactDOM.createPortal(element, container)`.
// They are indispensable for UI elements that must visually break out of their
// parent containers—such as modals, tooltips, pop‑overs, and global banners.

// 🔧 Core API
// ReactDOM.createPortal(<ChildComponent />, containerElement);
// Event bubbling still works as if the portal lives in the parent tree.

// 🌟 Common Use Cases
// - Modals/Dialogs
// - Tooltips/Dropdowns
// - Toast/Notification systems
// - Context menus rendered at <body> level

// 🔥 Example: Modal Using Portals (TypeScript)
import ReactDOM from 'react-dom';
import React, { useState } from 'react';

// Ensure your public/index.html has: <div id="modal-root"></div>
const modalRoot = document.getElementById('modal-root') as HTMLElement;

interface ModalProps {
  onClose: () => void;
  children: React.ReactNode;
}

export const Modal: React.FC<ModalProps> = ({ onClose, children }) => {
  return ReactDOM.createPortal(
    <div
      style={{
        position: 'fixed',
        inset: 0,
        background: 'rgba(0,0,0,0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        style={{ background: '#fff', padding: '1.5rem', borderRadius: 8, minWidth: 300 }}
        onClick={(e) => e.stopPropagation()}
      >
        {children}
        <button onClick={onClose} style={{ marginTop: '1rem' }}>Close</button>
      </div>
    </div>,
    modalRoot
  );
};

export const PortalDemo: React.FC = () => {
  const [open, setOpen] = useState(false);
  return (
    <>
      <button onClick={() => setOpen(true)}>Open Modal</button>
      {open && (
        <Modal onClose={() => setOpen(false)}>
          <h2>Hello from the Portal!</h2>
          <p>This content is rendered outside the main DOM tree.</p>
        </Modal>
      )}
    </>
  );
};

// 🛠️ Best Practices
// - Maintain a dedicated <div id="portal-root"> sibling to <div id="root">.
// - Capture backdrop clicks by stopping propagation on the modal content.
// - Handle focus management & accessibility: role="dialog", aria‑modal="true".
// - Avoid excessive nested portals—be mindful of z‑index stacking contexts.
// - Clean up global event listeners in useEffect return callbacks.

// ⚠️ Caveats & SSR
// - Server‑side rendering requires matching portal containers in the initial HTML.
// - Portals render outside overflow/position contexts—ensure proper styling.
// - For React Native, portals aren’t present; use libraries like `react-native-modal`.

// 📚 Summary
// Portals provide a first‑class escape hatch when you need to break out of the
// normal DOM hierarchy yet still benefit from React’s reconciliation and event
// system. Master them to craft polished modals, tooltips, and overlay UIs.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// ==============================
// 96 - Error Boundaries in React (JavaScript)
// ==============================

// 📘 What Are Error Boundaries?
// Error boundaries are React components that catch JavaScript errors
// in their child component tree, log the errors, and display a fallback UI
// instead of crashing the whole app. They catch errors during rendering,
// in lifecycle methods, and in constructors of the children below them.
// NOTE: Only class components can currently implement an error boundary.

// 🔧 Implementation
import React, { Component, useState } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    // Update state so the next render shows the fallback UI
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // Log error details to an external service if desired
    console.error('❌ ErrorBoundary caught:', error, info);
  }

  reset = () => {
    this.setState({ hasError: false });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: '2rem', textAlign: 'center' }}>
          <h2>Something went wrong.</h2>
          <button onClick={this.reset}>Try again</button>
        </div>
      );
    }
    return this.props.children;
  }
}

// 🔥 Demo Component That Crashes
function BuggyCounter() {
  const [count, setCount] = useState(0);
  if (count === 5) throw new Error('I crashed at 5!');
  return <button onClick={() => setCount(count + 1)}>Clicked {count}</button>;
}

// ↪️ Using the Error Boundary
export function ErrorBoundaryDemo() {
  return (
    <ErrorBoundary>
      <BuggyCounter />
    </ErrorBoundary>
  );
}

// 🛠️ Best Practices
// - Wrap independent UI sections individually so one crash doesn’t blank the entire app.
// - Integrate with error logging services (Sentry, Bugsnag, etc.) in componentDidCatch.
// - Provide helpful fallback UIs and a way to retry/reset the state.
// - Remember: event‑handler and async errors aren’t caught—handle those separately.

// 📚 Summary
// Error boundaries are a final‑line UX safeguard, preventing a single component
// failure from taking down the whole React tree, while giving users a graceful
// fallback and developers useful diagnostics.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// Topic 97: Render Props and Higher-Order Components (HOCs) – Detailed Notes and Code Examples
//
// Render Props and HOCs are patterns for reusing component logic in React.
// Render Props use a function prop to share code between components. HOCs wrap
// components to inject additional props or behavior.
//
// 1. Render Props:
//    • A component accepts a prop (often named render or children) that is a function.
//    • This function returns JSX, allowing dynamic rendering based on shared logic.
//
// Example: MouseTracker with Render Prop
import React, { Component } from 'react';

export class MouseTracker extends Component {
  state = { x: 0, y: 0 };

  handleMouseMove = e => {
    this.setState({ x: e.clientX, y: e.clientY });
  };

  render() {
    return (
      <div style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}>
        {this.props.render(this.state)}
      </div>
    );
  }
}

// Usage:
// <MouseTracker render={({ x, y }) => (<h1>Mouse at ({x}, {y})</h1>)} />
// or using children as render prop:
// <MouseTracker>{({ x, y }) => <h1>Mouse at ({x}, {y})</h1>}</MouseTracker>

// 2. Higher-Order Components (HOC):
//    • A function that takes a component and returns a new component with added props or logic.
//    • Does not modify the input component; wraps it.
//
// Example: withLoading HOC
import React from 'react';

export function withLoading(Component) {
  return function WithLoading(props) {
    if (props.isLoading) {
      return <div>Loading...</div>;
    }
    return <Component {...props} />;
  };
}

// Usage:
// const UserListWithLoading = withLoading(UserList);
// <UserListWithLoading isLoading={true} users={[]} />

// 3. Comparison:
//    • Render Props provide inline logic via functions, enabling flexible composition.
//    • HOCs wrap components for reuse, but can lead to wrapper hell and obscure devtools names.
//
// 4. Best Practices:
//    • Use clear prop names (e.g., render, children) for render props.
//    • Name HOCs for easier debugging: function withAuth(Component) { ... }
//    • Prefer hooks for new projects; render props and HOCs are legacy patterns.
//
// End of Topic 97

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 98: Compound Components Pattern – Detailed Notes and Code Examples
//
// The Compound Components pattern allows components to share implicit state
// via React context, enabling an expressive, flexible API while keeping
// state logic centralized. Users compose a parent component with specific
// child components to render complex UIs.
//
// Key Concepts:
// 1. Parent component holds shared state and context provider.
// 2. Child components consume context to access state and actions.
// 3. API communicates via JSX composition rather than props drilling.
//
// Example: Tabs Component
import React, { createContext, useContext, useState } from 'react';

// Context to share selected tab index
const TabsContext = createContext();

export function Tabs({ children, defaultIndex = 0 }) {
  const [selectedIndex, setSelectedIndex] = useState(defaultIndex);
  return (
    <TabsContext.Provider value={{ selectedIndex, setSelectedIndex }}>
      <div className="tabs">{children}</div>
    </TabsContext.Provider>
  );
}

// TabList renders buttons for each Tab
export function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}

// Tab consumes context to render and activate
export function Tab({ index, children }) {
  const { selectedIndex, setSelectedIndex } = useContext(TabsContext);
  const isSelected = index === selectedIndex;
  return (
    <button
      className={isSelected ? 'tab active' : 'tab'}
      onClick={() => setSelectedIndex(index)}
    >
      {children}
    </button>
  );
}

// TabPanels renders panels for each TabPanel
export function TabPanels({ children }) {
  return <div className="tab-panels">{children}</div>;
}

// TabPanel consumes context to conditionally render
export function TabPanel({ index, children }) {
  const { selectedIndex } = useContext(TabsContext);
  return selectedIndex === index ? (
    <div className="tab-panel">{children}</div>
  ) : null;
}

// Usage:
// <Tabs defaultIndex={1}>
//   <TabList>
//     <Tab index={0}>Home</Tab>
//     <Tab index={1}>Profile</Tab>
//     <Tab index={2}>Settings</Tab>
//   </TabList>
//   <TabPanels>
//     <TabPanel index={0}><HomeContent /></TabPanel>
//     <TabPanel index={1}><ProfileContent /></TabPanel>
//     <TabPanel index={2}><SettingsContent /></TabPanel>
//   </TabPanels>
// </Tabs>

// Notes:
// • Compound components offer clear, semantic APIs without prop drilling.
// • Shared context centralizes state management for children.
// • Avoid unnecessary re-renders by splitting context values if needed.
// • Use displayName on compound components for better debugging.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////



// Topic 99: Declarative Animations with Framer Motion – Detailed Notes and Code Examples
//
// Framer Motion is a popular React library for declarative animations and gestures.
// It provides simple APIs to animate components with spring physics, keyframes,
// and layout transitions, enhancing UI interactivity.
//
// Key Concepts:
// 1. Installation:
//    • npm install framer-motion
//
// 2. motion Components:
//    • Replace HTML elements with motion equivalents:
//      import { motion } from 'framer-motion';
//      <motion.div animate={{ opacity: 1 }} initial={{ opacity: 0 }} />
//
// 3. Props:
//    • initial: starting style
//    • animate: target style
//    • exit: style when component unmounts (with AnimatePresence)
//    • transition: timing, easing, duration, type (spring, tween)
//
// 4. AnimatePresence:
//    • Enables exit animations for conditional components.
//      Wrap siblings: <AnimatePresence>{condition && <motion.div exit={{ opacity: 0 }} />}</AnimatePresence>
//
// 5. Variants:
//    • Define animation states for reuse:
//      const variants = { hidden: { opacity: 0 }, visible: { opacity: 1 } };
//      <motion.div variants={variants} initial="hidden" animate="visible" />
//
// 6. Gestures:
//    • Drag, hover, tap animations via props:
//      <motion.div whileHover={{ scale: 1.1 }} whileTap={{ scale: 0.9 }} drag />
//
// Code Example: Fading List Items with staggered entrance
import React from 'react';
import { motion } from 'framer-motion';

const listVariants = {
  hidden: { opacity: 0 },
  visible: { opacity: 1, transition: { staggerChildren: 0.1 } }
};

const itemVariants = {
  hidden: { opacity: 0, y: -10 },
  visible: { opacity: 1, y: 0 }
};

export function AnimatedList({ items }) {
  return (
    <motion.ul initial="hidden" animate="visible" variants={listVariants}>
      {items.map((item, idx) => (
        <motion.li key={idx} variants={itemVariants}>
          {item}
        </motion.li>
      ))}
    </motion.ul>
  );
}

// Code Example: Page Transitions with AnimatePresence
import { AnimatePresence } from 'framer-motion';

export function Page({ isVisible, children }) {
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ x: 300, opacity: 0 }}
          animate={{ x: 0, opacity: 1 }}
          exit={{ x: -300, opacity: 0 }}
          transition={{ type: 'spring', stiffness: 100 }}
        >
          {children}
        </motion.div>
      )}
    </AnimatePresence>
  );
}

// Notes:
// • Use AnimatePresence to allow components to animate on unmount.
// • Variants help organize complex animations and maintain consistency.
// • Combine props like whileHover, whileTap for interactive feedback.
// • Transition types include spring (physics-based) and tween (easing-based).
// • Framer Motion supports layout animations with layout prop for smooth reordering.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 100: Server Components (React 19+ Preview) – Detailed Notes and Example Usage
//
// Server Components allow rendering parts of a React app on the server,
// enabling zero-bundle-size components, improved performance, and
// direct access to backend resources. Introduced experimentally in React 19+.
//
// Key Concepts:
// 1. Distinction:
//    • Server Components (RSC): rendered on the server, cannot use state or effects.
//    • Client Components: rendered on the client, support interactivity (state, hooks).
//
// 2. File Convention:
//    • Use .server.jsx for server components.
//    • Use .client.jsx for components requiring client-side behavior.
//
// 3. Data Fetching:
//    • Server Components can fetch data directly without bundling fetch logic for the client.
//    • No need for useEffect or SWR; simply await database or API calls.
//
// 4. Props and Composition:
//    • Server Components can pass serializable props to Client Components.
//    • Mix server and client components within the tree; client components hydrate.
//
// 5. Performance:
//    • Zero client bundle size for server components.
//    • Reduced JS execution and improved TTFB (time to first byte).
//
// 6. Limitations:
//    • No access to browser-only APIs (window, document).
//    • Cannot use useState, useEffect, or event handlers.
//
// Example: Server Component (UserList.server.jsx)
import React from 'react';
import { fetchUsers } from '../services/userService';
import UserCard from './UserCard.client';

export default async function UserList() {
  const users = await fetchUsers(); // server-only data fetch
  return (
    <div>
      {users.map(user => (
        // pass user data to client component for interactivity
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// Example: Client Component (UserCard.client.jsx)
'use client';
import React, { useState } from 'react';

export default function UserCard({ user }) {
  const [expanded, setExpanded] = useState(false);
  return (
    <div className="user-card">
      <h3 onClick={() => setExpanded(e => !e)}>{user.name}</h3>
      {expanded && <p>Email: {user.email}</p>}
    </div>
  );
}

// Example: Page Entry (app/page.jsx)
import React from 'react';
import UserList from '../components/UserList.server';

export default function Page() {
  return (
    <main>
      <h1>Users</h1>
      <UserList />
    </main>
  );
}

// Notes:
// • Prefix client components with 'use client'; default exports without directive are server components.
// • React automatically splits server and client bundles based on annotations.
// • Ensure props passed from server to client are serializable (no functions).
// • Use server components for heavy data fetching and static UI; wrap in client components for interactivity.
// • Server Components are experimental; require React 19+ and appropriate framework support (e.g., Next.js 14+).

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 107: Skeleton Loaders and Shimmer Effects – Detailed Notes and Code Examples
//
// Skeleton loaders and shimmer effects improve perceived performance by showing
// placeholder UI while data is loading. They visually communicate structure
// without blank screens or spinners, reducing layout shift.
//
// Key Concepts:
// 1. Skeleton UI:
//    • Gray or colored blocks matching content dimensions.
//    • Mimics final layout (cards, text lines, images).
//
// 2. Shimmer Animation:
//    • Subtle moving gradient overlay to imply activity.
//    • CSS keyframes or libraries (e.g., react-content-loader).
//
// 3. Implementation Approaches:
//    • Custom CSS: divs with background and animation.
//    • SVG-based: use <ContentLoader> from react-content-loader.
//    • Component Libraries: Material-UI’s Skeleton component.
//
// 4. Accessibility:
//    • Mark skeleton elements with aria-busy and aria-label.
//    • Hide placeholder content from screen readers via aria-hidden.
//
// Example 1: Custom CSS Skeleton Component
import React from 'react';
import './Skeleton.css'; // see CSS below

export function Skeleton({ width = '100%', height = '1rem', style = {} }) {
  return (
    <div
      className="skeleton"
      aria-busy="true"
      aria-label="Loading placeholder"
      style={{ width, height, ...style }}
    />
  );
}

// Skeleton.css
/*
.skeleton {
  background-color: #eee;
  position: relative;
  overflow: hidden;
}
.skeleton::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  height: 100%;
  width: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite;
}
@keyframes shimmer {
  100% { transform: translateX(100%); }
}
*/

// Usage:
// <Skeleton width="200px" height="200px" />
// <Skeleton height="1.5rem" style={{ marginBottom: '0.5rem' }} />

// Example 2: react-content-loader SVG
import React from 'react';
import ContentLoader from 'react-content-loader';

export function CardSkeleton() {
  return (
    <ContentLoader
      speed={2}
      width={400}
      height={160}
      viewBox="0 0 400 160"
      backgroundColor="#eee"
      foregroundColor="#ddd"
    >
      <rect x="0" y="0" width="400" height="160" rx="8" />
      <circle cx="80" cy="80" r="30" />
      <rect x="130" y="50" width="200" height="13" />
      <rect x="130" y="74" width="150" height="13" />
      <rect x="0" y="120" width="400" height="20" />
    </ContentLoader>
  );
}

// Example 3: Material-UI Skeleton
import React from 'react';
import { Skeleton as MuiSkeleton } from '@mui/material';

export function ProfileSkeleton() {
  return (
    <div>
      <MuiSkeleton variant="circular" width={40} height={40} />
      <MuiSkeleton variant="text" width="60%" />
      <MuiSkeleton variant="rectangular" width="100%" height={118} />
    </div>
  );
}

// Notes:
// • Place skeletons in layout positions to avoid content shift.
// • Adjust shimmer speed and colors to match brand aesthetics.
// • Replace skeletons with real data once loaded using conditional rendering.
// • Use SVG-based loaders for complex shapes; CSS for simple blocks.
// • Leverage library components for rapid development and accessibility built-in.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

// Topic 108: Toast Notifications with react-toastify – Detailed Notes and Code Examples
//
// react-toastify is a popular library for declarative, customizable toast (notification)
// messages in React applications. It supports stackable alerts, positions, and various types.
//
// Key Concepts:
// 1. Installation:
//    • npm install react-toastify
//    • yarn add react-toastify
//
// 2. Setup:
//    • Import CSS once, e.g., in index.js: import 'react-toastify/dist/ReactToastify.css';
//    • Render <ToastContainer /> at root of app (typically in App.jsx).
//    • Use toast methods to trigger notifications.
//
// 3. Toast API:
//    • toast.success('Success message');
//    • toast.error('Error message');
//    • toast.info('Info message');
//    • toast.warn('Warning message');
//    • toast('Default message');
//    • toast.dismiss() to clear all toasts.
//
// 4. Options:
//    • position: 'top-right', 'top-center', 'bottom-left', etc.
//    • autoClose: number (ms) or false to disable.
//    • hideProgressBar: boolean.
//    • closeOnClick, pauseOnHover, draggable, pauseOnFocusLoss.
//    • toastId to prevent duplicates.
//
// 5. Custom Content:
//    • Pass a React component: toast(<CustomComponent />).
//    • Use <ToastContainer bodyClassName="custom-toast" /> for styling.
//
// Code Example: Basic Usage in App.jsx
import React from 'react';
import { ToastContainer, toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

export function App() {
  const notifySuccess = () => toast.success('Operation successful!');
  const notifyError = () => toast.error('Something went wrong.');

  return (
    <div>
      <button onClick={notifySuccess}>Show Success</button>
      <button onClick={notifyError}>Show Error</button>
      <ToastContainer
        position="top-right"
        autoClose={3000}
        hideProgressBar={false}
        newestOnTop={false}
        closeOnClick
        rtl={false}
        pauseOnFocusLoss
        draggable
        pauseOnHover
      />
    </div>
  );
}

// Code Example: Custom Toast with Component
import React from 'react';
import { toast } from 'react-toastify';

function CustomToast({ message, closeToast }) {
  return (
    <div onClick={closeToast} style={{ cursor: 'pointer' }}>
      <strong>{message}</strong>
      <div>Click to dismiss</div>
    </div>
  );
}

export function notifyCustom(message) {
  toast.info(<CustomToast message={message} />, {
    position: 'bottom-left',
    autoClose: false,
    closeButton: false,
  });
}

// Code Example: Preventing Duplicate Toasts
export function notifyOnce(id, message) {
  toast(message, { toastId: id });
}

// Usage:
// notifyOnce('login-error', 'Login failed'); // only one toast with this ID

// Notes:
// • Place <ToastContainer /> once in root; multiple containers show multiple stacks.
// • Configure container props globally or per-container basis.
// • Use custom classes or styled-components to theme toasts.
// • For accessibility, toast messages are announced by screen readers by default.
// • Dismiss toasts programmatically with toast.dismiss(toastId).

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 109: Accessibility (ARIA, Tab Order, Focus Trap) – Detailed Notes and Code Examples
//
// Ensuring accessibility in React applications involves proper use of ARIA attributes,
// managing keyboard navigation (tab order), and implementing focus traps for modal dialogs.
// These practices make apps usable for keyboard and screen reader users.
//
// Key Concepts:
// 1. ARIA Attributes:
//    • role: Define element semantics (e.g., role="alert", role="dialog").
//    • aria-label / aria-labelledby: Provide accessible names for controls and regions.
//    • aria-describedby: Link to descriptive text or instructions.
//    • aria-hidden: Hide non-interactive elements from assistive tech.
//    • aria-live: Announce dynamic updates (e.g., aria-live="polite" for status messages).
//
// 2. Tab Order:
//    • HTML follows source order for tabbing by default.
//    • tabindex="0" makes non-focusable element focusable in natural tab sequence.
//    • tabindex="-1" makes element programmatically focusable but removed from tab order.
//    • Avoid positive tabindex values (tabindex>0) as they disrupt logical order.
//
// 3. Focus Trap:
//    • Constrain focus within a modal or drawer when open.
//    • Return focus to the triggering element on close.
//    • Libraries like focus-trap-react simplify implementing traps.
//
// Code Example 1: ARIA Live Region for Toasts
import React from 'react';

export function StatusMessage({ message }) {
  return (
    <div role="status" aria-live="polite" aria-atomic="true">
      {message}
    </div>
  );
}

// Code Example 2: Managing Tab Order
export function CustomButton() {
  return (
    <div>
      <button>First</button>
      <div tabIndex={0} role="button" onClick={() => alert('Div clicked')}>
        Focusable Div Button
      </div>
      <button>Second</button>
    </div>
  );
}

// Code Example 3: Focus Trap in Modal using focus-trap-react
import React, { useRef, useEffect } from 'react';
import FocusTrap from 'focus-trap-react';

export function Modal({ isOpen, onClose, children }) {
  const closeButtonRef = useRef(null);

  useEffect(() => {
    if (isOpen && closeButtonRef.current) {
      closeButtonRef.current.focus();
    }
  }, [isOpen]);

  if (!isOpen) return null;

  return (
    <FocusTrap>
      <div role="dialog" aria-modal="true" aria-labelledby="modal-title" className="modal">
        <h2 id="modal-title">Modal Title</h2>
        <button ref={closeButtonRef} onClick={onClose} aria-label="Close modal">
          Close
        </button>
        <div>{children}</div>
      </div>
    </FocusTrap>
  );
}

// Notes:
// • Use role="status" and aria-live for dynamic status updates.
// • Keep DOM order logical for intuitive keyboard navigation.
// • Use tabindex sparingly; prefer native elements.
// • FocusTrap ensures focus remains within modal while open.
// • Always return focus to the trigger element after closing overlays.
// • Test accessibility using keyboard only and screen reader tools (VoiceOver, NVDA).

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 110: Dark/Light Theme Toggling – Detailed Notes and Code Examples
//
// Implementing dark/light mode allows users to switch between color schemes
// for better accessibility and user preference. Common approaches include
// CSS variables, context for global state, and persisting user choice.
//
// Key Concepts:
// 1. CSS Variables:
//    • Define theme colors in :root and [data-theme="dark"] selectors.
//    • Example:
//      :root { --bg: #fff; --text: #000; }
//      [data-theme="dark"] { --bg: #000; --text: #fff; }
//
// 2. Theme Context:
//    • Create React Context to provide current theme and toggle function.
//    • Consume context in components to apply or switch themes.
//
// 3. Persisting Preference:
//    • Store user choice in localStorage or system preference via matchMedia.
//    • Read stored/theme-media on load.
//
// 4. Toggles and Icons:
//    • Provide a toggle button that updates context and CSS attribute.
//    • Optionally use sun/moon icons for visual cue.
//
// Code Example: ThemeProvider with CSS Variables
import React, { createContext, useState, useEffect, useContext } from 'react';

const ThemeContext = createContext({ theme: 'light', toggle: () => {} });

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // On mount, read stored preference or system setting
  useEffect(() => {
    const stored = localStorage.getItem('theme');
    if (stored) setTheme(stored);
    else if (window.matchMedia('(prefers-color-scheme: dark)').matches) setTheme('dark');
  }, []);

  // Apply theme attribute and store
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggle = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggle }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}

// Code Example: Toggle Button Component
import React from 'react';
import { useTheme } from './ThemeProvider';

export function ThemeToggle() {
  const { theme, toggle } = useTheme();
  return (
    <button onClick={toggle} aria-label="Toggle theme">
      {theme === 'light' ? '🌞 Light' : '🌜 Dark'}
    </button>
  );
}

// CSS (e.g., index.css)
/*
:root {
  --bg: #ffffff;
  --text: #000000;
}
[data-theme="dark"] {
  --bg: #121212;
  --text: #ffffff;
}
body {
  background-color: var(--bg);
  color: var(--text);
  transition: background-color 0.3s, color 0.3s;
}
*/

// Usage in App.jsx:
// import { ThemeProvider } from './ThemeProvider';
// import { ThemeToggle } from './ThemeToggle';
//
// function App() {
//   return (
//     <ThemeProvider>
//       <ThemeToggle />
//       <MainContent />
//     </ThemeProvider>
//   );
// }

// Notes:
// • Using CSS variables allows seamless theme switching without inline styles.
// • Persist preference in localStorage for user consistency.
// • Match system settings on first load for best UX.
// • Wrap your app in ThemeProvider to access theme state anywhere.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 115: Atomic Design Pattern – Detailed Notes and Code Examples
//
// The Atomic Design Pattern, introduced by Brad Frost, structures UI components into
// hierarchical categories: atoms, molecules, organisms, templates, and pages. This
// promotes consistency, reusability, and scalability in component libraries.
//
// 1. Atoms:
//    • The smallest, indivisible UI elements (buttons, inputs, labels).
//    • Serve as building blocks for more complex components.
//
// Example: Atom – Button.jsx
import React from 'react';
import PropTypes from 'prop-types';

export function Button({ children, onClick, type = 'button' }) {
  return (
    <button type={type} onClick={onClick} className="btn">
      {children}
    </button>
  );
}

Button.propTypes = {
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func,
  type: PropTypes.oneOf(['button', 'submit', 'reset']),
};

// 2. Molecules:
//    • Combinations of atoms working together as a unit (e.g., input with label).
//
// Example: Molecule – SearchInput.jsx
import React from 'react';
import { Button } from './Button'; // atom

export function SearchInput({ value, onChange, onSearch }) {
  return (
    <div className="search-input">
      <input type="text" value={value} onChange={e => onChange(e.target.value)} placeholder="Search..." />
      <Button onClick={() => onSearch(value)}>Go</Button>
    </div>
  );
}

// 3. Organisms:
//    • Groups of molecules and/or atoms forming a distinct section (e.g., header with nav and logo).
//
// Example: Organism – Header.jsx
import React from 'react';
import { SearchInput } from './SearchInput'; // molecule

export function Header({ onSearch }) {
  const [query, setQuery] = React.useState('');
  return (
    <header className="site-header">
      <h1 className="logo">MyApp</h1>
      <nav className="main-nav">
        <a href="/">Home</a>
        <a href="/about">About</a>
      </nav>
      <SearchInput value={query} onChange={setQuery} onSearch={onSearch} />
    </header>
  );
}

// 4. Templates:
//    • Page-level structures combining organisms into layout placeholders.
//    • Define layout without final content.
//
// Example: Template – MainLayout.jsx
import React from 'react';
import { Header } from '../organisms/Header';

export function MainLayout({ children, onSearch }) {
  return (
    <div className="app-container">
      <Header onSearch={onSearch} />
      <main className="content">{children}</main>
      <footer className="site-footer">© 2025 MyApp</footer>
    </div>
  );
}

// 5. Pages:
//    • Specific views using templates and populating with real data.
//
// Example: Page – HomePage.jsx
import React from 'react';
import { MainLayout } from '../templates/MainLayout';
import { Card } from '../organisms/Card';

export function HomePage() {
  const handleSearch = term => console.log('Search for', term);
  const items = [{ id: 1, title: 'First' }, { id: 2, title: 'Second' }];

  return (
    <MainLayout onSearch={handleSearch}>
      {items.map(item => (
        <Card key={item.id} title={item.title} />
      ))}
    </MainLayout>
  );
}

// Notes:
// • Organize folders by atomic category: src/components/atoms, molecules, organisms, templates, pages.
// • Promote reusability: atoms never import other components; molecules import atoms, etc.
// • Improves collaboration: clear roles and responsibilities for component sizes.
// • Enables scalable design systems aligned with design tokens and style guides.
// • Maintain consistent naming and folder conventions for discoverability.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////



// Topic 117: Secure Token Handling (HttpOnly Cookies vs localStorage) – Detailed Notes and Code Examples
//
// Secure token handling is essential to protect against XSS and CSRF attacks.
// Two primary storage approaches for JWTs or session tokens are HttpOnly cookies
// and browser storage (localStorage/sessionStorage). Each has trade-offs.
//
// 1. HttpOnly Cookies:
//    • Cookies set by the server with the HttpOnly flag cannot be accessed via JavaScript.
//    • Protects against XSS since scripts cannot read the token.
//    • Use SameSite and Secure flags to mitigate CSRF and ensure HTTPS-only transmission.
//    • Tokens auto-sent with every request to the cookie’s domain.
//
// Example: Server Sets HttpOnly Cookie (Express.js)
// import express from 'express';
// app.post('/login', (req, res) => {
//   const token = generateJwt(req.user);
//   res.cookie('token', token, {
//     httpOnly: true,
//     secure: true,
//     sameSite: 'lax',
//     maxAge: 24 * 60 * 60 * 1000, // 1 day
//   });
//   res.sendStatus(200);
// });
//
// Client Request (fetch includes credentials)
// fetch('/protected', { method: 'GET', credentials: 'include' });
//
// 2. localStorage/sessionStorage:
//    • JavaScript-accessible storage; vulnerable to XSS attacks.
//    • Easy to implement: setItem/getItem.
//    • Better control over expiration and manual cleanup.
//    • Requires manual inclusion of token in Authorization header.
//
// Example: Storing and Using Token in localStorage
// // On login success:
// localStorage.setItem('token', token);
// // API request:
// const token = localStorage.getItem('token');
// fetch('/api/data', {
//   headers: { 'Authorization': `Bearer ${token}` }
// });
//
// 3. Best Practices:
//    • Prefer HttpOnly cookies for enhanced security; pair with CSRF tokens or SameSite.
//    • Sanitize and validate all inputs to prevent XSS.
//    • Implement CSRF protection (double-submit cookie, hidden header token).
//    • Use short-lived tokens and refresh flows to limit exposure.
//    • Always use HTTPS to protect token in transit.
//
// 4. Token Refresh:
//    • Store refresh token in HttpOnly cookie; access token in-memory.
//    • On access token expiration, call /refresh endpoint (credentials: 'include') to renew.
//
// React Hook Example: useAuth for HttpOnly Cookie Flow
import { useState, useEffect, useCallback } from 'react';

export function useAuth() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const fetchUser = useCallback(async () => {
    try {
      const res = await fetch('/me', { credentials: 'include' });
      if (res.ok) setUser(await res.json());
      else setUser(null);
    } catch {
      setUser(null);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => { fetchUser(); }, [fetchUser]);

  const login = async (credentials) => {
    const res = await fetch('/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials),
      credentials: 'include',
    });
    if (res.ok) await fetchUser();
    return res.ok;
  };

  const logout = async () => {
    await fetch('/logout', { method: 'POST', credentials: 'include' });
    setUser(null);
  };

  return { user, loading, login, logout };
}

// Notes:
// • HttpOnly cookies minimize XSS risk; localStorage offers ease but less secure.
// • Use credentials: 'include' in fetch to send cookies.
// • Maintain authentication state in-memory, not in localStorage, when using cookies.
// • Always clear cookies and storage on logout to prevent token reuse.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


// Topic 118: Using .env Securely in Production – Detailed Notes and Code Examples
//
// Environment variables (.env) store configuration secrets (API keys, URLs) separately
// from code. In production, secure handling ensures secrets are not exposed inadvertently.
//
// Key Concepts:
// 1. .env Files:
//    • .env.local for local development; .env.production for production builds.
//    • Do NOT commit .env files to version control; add to .gitignore.
//
// 2. Build-Time Injection:
//    • Tools like Create React App inline env vars prefixed with REACT_APP_ at build time.
//    • Only available variables are exposed in client bundles.
//    • Avoid embedding secrets in client-side code; use backend proxies.
//
// 3. Server-Side Storage:
//    • Store sensitive vars on server or CI/CD pipeline (e.g., GitHub Actions Secrets).
//    • Inject at runtime into Docker containers or server environment.
//
// 4. Runtime Config for SSR/Node:
//    • In Next.js or Node services, access process.env directly without exposing to client.
//    • Use dotenv library on server to load .env before application start.
//
// 5. CI/CD Integration:
//    • Configure environment variables in CI settings (GitHub Actions, CircleCI).
//    • Avoid storing plaintext in repos; rely on encrypted secret storage.
//
// Code Example: Create React App Production Build
// .env.production (not committed)
REACT_APP_API_URL=https://api.myapp.com
REACT_APP_ANALYTICS_KEY=prod-analytics-key

// Usage in code (client-safe vars only):
// fetch(`${process.env.REACT_APP_API_URL}/data`)
// analytics.init(process.env.REACT_APP_ANALYTICS_KEY)

// Code Example: Node Server with dotenv
// Install: npm install dotenv
// server.js
import express from 'express';
import dotenv from 'dotenv';

dotenv.config(); // loads .env into process.env
const app = express();
const port = process.env.PORT || 3000;

app.get('/secret', (req, res) => {
  res.json({ secret: process.env.SECRET_TOKEN });
});

app.listen(port, () => console.log(`Server running on port ${port}`));

// CI/CD Example (GitHub Actions YAML snippet)
// jobs:
//   build:
//     runs-on: ubuntu-latest
//     env:
//       API_URL: ${{ secrets.API_URL }}
//     steps:
//       - uses: actions/checkout@v2
//       - name: Build
//         run: |
//           echo "REACT_APP_API_URL=$API_URL" > .env.production
//           npm ci
//           npm run build

// Best Practices:
// • Never expose private keys in client-side bundles; only public config (e.g., API endpoints).
// • Rotate secrets regularly and revoke compromised credentials immediately.
// • Use vault services (AWS Secrets Manager, HashiCorp Vault) for advanced secret management.
// • Monitor for accidental secret commits using tools like git-secrets or GitGuardian.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////




// Topic 119: Animating Route Transitions – Detailed Notes and Code Examples
//
// Animating route transitions enhances UX by providing visual context when
// navigating between pages. In React Router v6 and frameworks like Next.js,
// use libraries like Framer Motion to animate components on mount and unmount.
//
// Key Concepts:
// 1. AnimatePresence:
//    • Wrap <Routes> or page components to enable exit animations.
//    • Needed for unmount animations as components leave the tree.
//
// 2. motion Components:
//    • Use <motion.div> or <motion.main> for page wrappers.
//    • Define initial, animate, and exit variants for transitions.
//
// 3. LayoutId for Shared Element Transitions:
//    • Assign a shared layoutId to elements to animate between positions across routes.
//
// 4. React Router Integration:
//    • Use useLocation to key <AnimatePresence> and <Routes> on pathname.
//
// Code Example: Basic Route Transitions (React Router v6)
import React from 'react';
import { Routes, Route, useLocation } from 'react-router-dom';
import { AnimatePresence, motion } from 'framer-motion';
import Home from './Home';
import About from './About';

export function AnimatedRoutes() {
  const location = useLocation();
  const variants = {
    initial: { opacity: 0, x: 100 },
    animate: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: -100 }
  };

  return (
    <AnimatePresence exitBeforeEnter>
      <Routes location={location} key={location.pathname}>
        <Route path="/" element={
          <motion.div
            variants={variants}
            initial="initial"
            animate="animate"
            exit="exit"
            transition={{ duration: 0.3 }}
          >
            <Home />
          </motion.div>
        } />
        <Route path="/about" element={
          <motion.div
            variants={variants}
            initial="initial"
            animate="animate"
            exit="exit"
            transition={{ duration: 0.3 }}
          >
            <About />
          </motion.div>
        } />
      </Routes>
    </AnimatePresence>
  );
}

// Code Example: Shared Element Transition
import React from 'react';
import { motion } from 'framer-motion';

export function Card({ id, title, to }) {
  return (
    <Link to={to}>
      <motion.div layoutId={`card-${id}`} className="card">
        <h2>{title}</h2>
      </motion.div>
    </Link>
  );
}

export function DetailedCard({ id }) {
  return (
    <motion.div layoutId={`card-${id}`} className="card-detail">
      <p>Details for card {id}</p>
    </motion.div>
  );
}

// Notes:
// • Wrap routes with AnimatePresence and key by pathname for exit animations.
// • motion components support variants for DRY animation definitions.
// • Use layoutId for animating shared elements across route changes.
// • Adjust transition durations and easings to match design guidelines.
// • Ensure exitBeforeEnter to complete exit animation before entering next route.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////



// Topic 120: Advanced Routing Strategies in Large Apps – Detailed Notes and Code Examples
//
// Large-scale React applications often require advanced routing techniques to optimize
// performance, maintainability, and user experience. Strategies include code splitting,
// route grouping, nested routing, and dynamic route loading.
//
// Key Concepts:
// 1. Route-based Code Splitting:
//    • Leverage React.lazy and Suspense to split on route boundaries.
//    • Define separate chunks for major application sections.
//
// 2. Nested Routes and Layouts:
//    • Use React Router’s nested <Routes> to share layout components (e.g., dashboards, admin panels).
//    • Avoid prop drilling by placing context providers at layout routes.
//
// 3. Route Guards and Middleware:
//    • Implement authentication and authorization checks with wrapper components or loaders.
//    • Redirect unauthorized users to login or error pages.
//
// 4. Dynamic Route Loading:
//    • Fetch route configuration from the server for feature toggles or A/B tests.
//    • Render routes based on user roles or feature flags.
//
// 5. URL State and Query Management:
//    • Use libraries like React Router’s useSearchParams or query-string to parse and sync URL query params.
//    • Encode UI state (filters, pagination) in URL for shareable links.
//
// 6. Scroll Restoration:
//    • Implement custom scroll behavior on route changes (e.g., scroll to top or saved positions).
//    • Use useEffect with useLocation to manage scroll.
//
// Code Example: Nested Layout Routes
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate, Outlet } from 'react-router-dom';

function DashboardLayout() {
  return (
    <div>
      <Sidebar />
      <main><Outlet /></main>
    </div>
  );
}

export function AppRouter() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/dashboard" element={<ProtectedRoute><DashboardLayout /></ProtectedRoute>}>
          <Route index element={<DashboardHome />} />
          <Route path="users" element={<UserList />} />
          <Route path="settings" element={<Settings />} />
        </Route>
        <Route path="*" element={<Navigate to="/login" replace />} />
      </Routes>
    </BrowserRouter>
  );
}

// Code Example: Scroll Restoration Hook
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';

export function useScrollToTop() {
  const { pathname } = useLocation();
  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]);
}

// Usage in App:
// function App() {
//   useScrollToTop();
//   return <AppRouter />;
// }

// Notes:
// • Group related routes under common layouts for consistency and code reuse.
// • Use ProtectedRoute components to handle authentication logic.
// • Keep route definitions declarative and centralized.
// • Implement lazy loading on heavy routes to reduce initial bundle size.
// • Synchronize URL state for filters and pagination to enable deep-linking.

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
